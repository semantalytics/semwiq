### Eclipse Workspace Patch 1.0
#P ARQ-2.7.0
Index: src/com/hp/hpl/jena/sparql/algebra/op/OpBase.java
===================================================================
--- src/com/hp/hpl/jena/sparql/algebra/op/OpBase.java	(revision 6629)
+++ src/com/hp/hpl/jena/sparql/algebra/op/OpBase.java	(working copy)
@@ -15,10 +15,20 @@
 
 public abstract class OpBase extends PrintSerializableBase implements Op
 {
+	protected Object annotation;
+	
     @Override
     public abstract int hashCode() ;
     public abstract boolean equalTo(Op other, NodeIsomorphismMap labelMap) ;
 
+    public Object getAnnotation() {
+    	return annotation;
+    }
+    
+    public void setAnnotation(Object annotation) {
+    	this.annotation = annotation;
+    }
+    
     @Override
     final public boolean equals(Object other)
     { 
Index: Grammar/arq.jj
===================================================================
--- Grammar/arq.jj	(revision 6629)
+++ Grammar/arq.jj	(working copy)
@@ -27,15 +27,21 @@
 
 package com.hp.hpl.jena.sparql.lang.arq ;
 
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
 import com.hp.hpl.jena.graph.* ;
 import com.hp.hpl.jena.query.* ;
+import com.hp.hpl.jena.sparql.algebra.table.TableN;
 import com.hp.hpl.jena.sparql.core.Var ;
 import com.hp.hpl.jena.sparql.syntax.* ;
 import com.hp.hpl.jena.sparql.expr.* ;
 import com.hp.hpl.jena.sparql.path.* ;
 
 import com.hp.hpl.jena.sparql.expr.aggregate.* ;
-
+import com.hp.hpl.jena.sparql.engine.binding.Binding;
+import com.hp.hpl.jena.sparql.engine.binding.BindingMap;
 
 import com.hp.hpl.jena.sparql.modify.op.* ;
 
@@ -56,6 +62,7 @@
 void Query() : { }
 {
   Prologue()
+  ( <EXPLAIN> { getQuery().setExplainFlag(); } ) ?
   ( SelectQuery() | ConstructQuery() | DescribeQuery() | AskQuery() )
 }
 
@@ -120,9 +127,49 @@
   { allowAggregatesInExpressions = false ; }
   ( DatasetClause() )*
   WhereClause()
+  ( <BINDINGS> Bindings() )?
   SolutionModifier()
 }
 
+void Bindings() : {
+	TableN t = new TableN();
+	List<Var> vars = new ArrayList<Var>();
+	Var v;
+	Iterator<Var> vIt;
+	Var next;
+	Node n;
+	Binding b = null;
+}
+{
+	( v = Var() { vars.add(v); } )* // get variables
+	<LBRACE>
+	( // for each binding
+		{ b = new BindingMap(); vIt = vars.iterator(); }
+		( // for each node of a binding
+			{
+				if (vIt.hasNext())
+					next = vIt.next();
+				else
+					throw new Error("Invalid initial binding: too few variables for binding.");
+			}
+			n = NullVarOrNode()
+			{ if (n != null) 
+				b.add(next, n); }
+		)*
+		<DOT>
+		{ t.addBinding(b); }
+	)* 
+	<RBRACE>
+	{ getQuery().setInitialBindingTable(t); }
+}
+
+Node NullVarOrNode() : { Node n; }
+{
+	( <NULL> { n = null; }
+	| n = VarOrTerm() )
+	{ return n; }
+}
+
 void ConstructQuery() : { Template t ; }
 {
   <CONSTRUCT>
@@ -140,15 +187,23 @@
   <DESCRIBE>
     { getQuery().setQueryDescribeType() ; }
   (
-    ( n = VarOrIRIref() { getQuery().addDescribeNode(n) ; } )+
-    { getQuery().setQueryResultStar(false) ; }
-  |
-    <STAR>
-    { getQuery().setQueryResultStar(true) ; }
+  	( <SERVICE> | <SELF> ) // allow DESCRIBE SELF or DESCRIBE SERVICE
+  	  { getQuery().setDescribeMode(Query.DESCRIBE_SELF); }
+    |
+    <DATASET>
+      { getQuery().setDescribeMode(Query.DESCRIBE_DATASET); }
+    |
+    (
+      ( n = VarOrIRIref() { getQuery().addDescribeNode(n) ; } )+
+      { getQuery().setQueryResultStar(false) ; }
+    |
+      <STAR>
+      { getQuery().setQueryResultStar(true) ; }
+    )
+    ( DatasetClause() )*
+    ( WhereClause() )?
+    SolutionModifier()
   )
-  ( DatasetClause() )*
-  ( WhereClause() )?
-  SolutionModifier()
 }
 
 void AskQuery() : {}
@@ -1405,6 +1460,7 @@
 // Prologue
    < BASE: "base" >
 | < PREFIX: "prefix" >
+| < EXPLAIN: "explain" >
 
 // Result forms
 | < SELECT: "select" >
@@ -1413,11 +1469,14 @@
 | < DESCRIBE: "describe" >
 | < CONSTRUCT: "construct" >
 | < ASK: "ask" >
+| < SELF: "self" >
+| < DATASET: "dataset" >
 
 | < LIMIT: "limit" >
 | < OFFSET: "offset" >
 | < ORDER: "order" >
 | < BY: "by" >
+| < BINDINGS: "bindings" >
 
 | < ASC: "asc" >
 | < DESC: "desc" >
@@ -1589,10 +1648,7 @@
 | < FPATH: "->" >
 | < RPATH: "<-" >
 | < QMARK: "?" >
-
-
-
-
+| < NULL: "null" >
 
 }
 
Index: src/com/hp/hpl/jena/sparql/algebra/op/OpLeftJoin.java
===================================================================
--- src/com/hp/hpl/jena/sparql/algebra/op/OpLeftJoin.java	(revision 6629)
+++ src/com/hp/hpl/jena/sparql/algebra/op/OpLeftJoin.java	(working copy)
@@ -33,7 +33,14 @@
         super(left, right) ;
         expressions = exprs ;
     }
-    
+
+	public void addExprs(ExprList exprs) {
+		if (expressions == null)
+			expressions = exprs;
+		else
+			expressions.addAll(exprs);
+	}
+	
     public ExprList getExprs()      { return expressions ; } 
     public String getName()         { return Tags.tagLeftJoin ; }
     
@@ -50,8 +57,9 @@
     public boolean equalTo(Op op2, NodeIsomorphismMap labelMap)
     {
         if ( ! ( op2 instanceof OpLeftJoin) ) return false ;
-        return super.sameArgumentsAs((Op2)op2, labelMap) ;
+        return super.sameArgumentsAs((Op2)op2, labelMap) && expressions.equals(((OpLeftJoin) op2).expressions);
     }
+
 }
 
 /*
Index: src/com/hp/hpl/jena/sparql/algebra/op/Op1.java
===================================================================
--- src/com/hp/hpl/jena/sparql/algebra/op/Op1.java	(revision 6629)
+++ src/com/hp/hpl/jena/sparql/algebra/op/Op1.java	(working copy)
@@ -21,7 +21,7 @@
     }
     
     public Op getSubOp() { return sub ; }
-    //public void setSubOp(Op op) { sub = op ; }
+    public void setSubOp(Op op) { sub = op ; }
     
     public abstract Op apply(Transform transform, Op subOp) ;
     public abstract Op copy(Op subOp) ;
Index: src/com/hp/hpl/jena/sparql/expr/ExprWalker.java
===================================================================
--- src/com/hp/hpl/jena/sparql/expr/ExprWalker.java	(revision 6629)
+++ src/com/hp/hpl/jena/sparql/expr/ExprWalker.java	(working copy)
@@ -22,7 +22,8 @@
     static public void walk(ExprVisitor visitor, Expr expr)
     { expr.visit(new WalkerTopDown(visitor)) ; }
     
-    
+	static public void walkBottomUp(ExprVisitor visitor, Expr expr)
+	{ expr.visit(new WalkerBottomUp(visitor)) ; }
     
     static class Walker implements ExprVisitor
     {
Index: src/com/hp/hpl/jena/sparql/algebra/op/OpN.java
===================================================================
--- src/com/hp/hpl/jena/sparql/algebra/op/OpN.java	(revision 6629)
+++ src/com/hp/hpl/jena/sparql/algebra/op/OpN.java	(working copy)
@@ -50,6 +50,10 @@
     public int hashCode()               { return elements.hashCode() ; } 
 
     public List<Op> getElements()           { return elements ; }
+    
+    public void setElements(List<Op> elements) {
+		this.elements = elements;
+	}
 
     public Iterator<Op> iterator()          { return elements.iterator() ; }
 }
Index: src/com/hp/hpl/jena/sparql/algebra/op/OpJoin.java
===================================================================
--- src/com/hp/hpl/jena/sparql/algebra/op/OpJoin.java	(revision 6629)
+++ src/com/hp/hpl/jena/sparql/algebra/op/OpJoin.java	(working copy)
@@ -11,11 +11,14 @@
 import com.hp.hpl.jena.sparql.algebra.Table;
 import com.hp.hpl.jena.sparql.algebra.Transform;
 import com.hp.hpl.jena.sparql.algebra.table.TableUnit;
+import com.hp.hpl.jena.sparql.expr.ExprList;
 import com.hp.hpl.jena.sparql.sse.Tags;
 import com.hp.hpl.jena.sparql.util.NodeIsomorphismMap;
 
 public class OpJoin extends Op2
 {
+	protected ExprList expressions = null;
+	
     public static Op create(Op left, Op right)
     {
         // Don't simplify here - changes SPARQL for OPTIONAL {{ FILTER }}
@@ -49,6 +52,31 @@
     public String getName() { return Tags.tagJoin ; }
 
     @Override
+    public int hashCode() {
+    	if (expressions != null)
+    		return super.hashCode() ^ expressions.hashCode();
+    	else
+    		return super.hashCode();
+    }
+    
+    /**
+     * if returns expressions this is a theta join, otherwise returns null
+     * @return
+     */
+    public ExprList getExprs() {
+		return expressions;
+	}
+    
+    /** 
+     * make OpJoin a conditional theta join
+     * 
+     * @param exprs
+     */
+    public void setExprs(ExprList exprs) {
+		this.expressions = exprs;
+	}
+    
+    @Override
     public Op apply(Transform transform, Op left, Op right)
     { return transform.transform(this, left, right) ; }
         
@@ -62,7 +90,7 @@
     public boolean equalTo(Op op2, NodeIsomorphismMap labelMap)
     {
         if ( ! ( op2 instanceof OpJoin) ) return false ;
-        return super.sameArgumentsAs((Op2)op2, labelMap) ;
+        return super.sameArgumentsAs((Op2)op2, labelMap) && expressions.equals(((OpLeftJoin) op2).expressions) ;
     }
 
 }
Index: src/com/hp/hpl/jena/sparql/engine/iterator/QueryIter2.java
===================================================================
--- src/com/hp/hpl/jena/sparql/engine/iterator/QueryIter2.java	(revision 6629)
+++ src/com/hp/hpl/jena/sparql/engine/iterator/QueryIter2.java	(working copy)
@@ -58,14 +58,20 @@
         
         out.print(Plan.startMarker) ;
         out.incIndent() ;
-        getLeft().output(out, sCxt) ;
+        if (getLeft() == null)
+        	out.println("left closed");
+        else
+        	getLeft().output(out, sCxt) ;
         out.decIndent() ;
         //out.ensureStartOfLine() ;
         out.println(Plan.finishMarker) ;
         
         out.print(Plan.startMarker) ;
         out.incIndent() ;
-        getRight().output(out, sCxt) ;
+        if (getRight() == null)
+        	out.println("right closed");
+        else
+        	getRight().output(out, sCxt) ;
         out.decIndent() ;
         //out.ensureStartOfLine() ;
         out.println(Plan.finishMarker) ;
Index: src/com/hp/hpl/jena/sparql/serializer/QuerySerializer.java
===================================================================
--- src/com/hp/hpl/jena/sparql/serializer/QuerySerializer.java	(revision 6629)
+++ src/com/hp/hpl/jena/sparql/serializer/QuerySerializer.java	(working copy)
@@ -12,10 +12,13 @@
 import com.hp.hpl.jena.graph.Node;
 import com.hp.hpl.jena.query.Query;
 import com.hp.hpl.jena.query.QueryVisitor;
+import com.hp.hpl.jena.query.ResultSet;
 import com.hp.hpl.jena.query.SortCondition;
+import com.hp.hpl.jena.sparql.algebra.table.TableN;
 import com.hp.hpl.jena.sparql.core.Prologue;
 import com.hp.hpl.jena.sparql.core.Var;
 import com.hp.hpl.jena.sparql.core.VarExprList;
+import com.hp.hpl.jena.sparql.engine.binding.Binding;
 import com.hp.hpl.jena.sparql.expr.Expr;
 import com.hp.hpl.jena.sparql.syntax.Element;
 import com.hp.hpl.jena.sparql.syntax.Template;
@@ -69,6 +72,9 @@
     
     public void visitSelectResultForm(Query query)
     {
+    	if (query.isExplainQuery())
+    		out.print("EXPLAIN ");
+    
         out.print("SELECT ") ;
         if ( query.isDistinct() )
             out.print("DISTINCT ") ;
@@ -85,6 +91,9 @@
     
     public void visitConstructResultForm(Query query)
     {
+    	if (query.isExplainQuery())
+    		out.print("EXPLAIN ");
+    
         out.print("CONSTRUCT ") ;
         if ( query.isQueryResultStar() )
         {
@@ -103,23 +112,41 @@
     
     public void visitDescribeResultForm(Query query)
     {
+    	if (query.isExplainQuery())
+    		out.print("EXPLAIN ");
+    
         out.print("DESCRIBE ") ;
         
-        if ( query.isQueryResultStar() )
-            out.print("*") ;
-        else
-        {
-            appendVarList(query, out, query.getResultVars()) ;
-            if ( query.getResultVars().size() > 0 &&
-                 query.getResultURIs().size() > 0 )
-                out.print(" ") ;
-            appendURIList(query, out, query.getResultURIs()) ;
-        }
+        // AndyL:
+        switch ( query.getDescribeMode() ) {
+        case Query.DESCRIBE_SELF:
+        	out.print("SELF") ;
+        	break;
+        
+        case Query.DESCRIBE_DATASET:
+        	out.print("DATASET") ;
+        	break;
+        
+        default:        
+        	if ( query.isQueryResultStar() )
+	            out.print("*") ;
+	        else
+	        {
+	            appendVarList(query, out, query.getResultVars()) ;
+	            if ( query.getResultVars().size() > 0 &&
+	                 query.getResultURIs().size() > 0 )
+	                out.print(" ") ;
+	            appendURIList(query, out, query.getResultURIs()) ;
+	        }
+    	}
         out.newline() ;
     }
     
     public void visitAskResultForm(Query query)
     {
+    	if (query.isExplainQuery())
+    		out.print("EXPLAIN ");
+    
         out.print("ASK") ;
         out.newline() ;
     }
@@ -161,9 +188,46 @@
             //el.visit(fmtElement) ;
             out.decIndent(BLOCK_INDENT) ;
             out.newline() ;
+            
+            serializeBindings(query); // by AndyL
         }
     }
     
+    /** by AndyL
+     * 
+     * @param query
+     */
+    private void serializeBindings(Query query) {
+    	TableN bindings = query.getInitialBindingTable();
+    	if (bindings != null) {
+    		ResultSet r = bindings.toResultSet();
+    		out.print("BINDINGS ");
+    		for (String var : r.getResultVars())
+    			out.print("?" + var + " ");
+    		out.print("{");
+    		out.newline();
+    		
+            out.incIndent(BLOCK_INDENT);
+            while (r.hasNext()) {
+            	Binding b = r.nextBinding();
+        		for (String var : r.getResultVars()) {
+        			Node n = b.get(Var.alloc(var));
+        			if (n != null)
+        				out.print(FmtUtils.stringForNode(n, query.getPrefixMapping()));
+        			else
+        				out.print("null");
+        			out.print(" ");
+        		}
+        		out.print(".");
+        		out.newline();
+            }
+            
+            out.decIndent(BLOCK_INDENT) ;
+            out.print("}");
+            out.newline();
+    	}
+    }
+    
     public void visitGroupBy(Query query)
     {
         if ( query.hasGroupBy() )
Index: src/com/hp/hpl/jena/sparql/engine/main/iterator/QueryIterUnion.java
===================================================================
--- src/com/hp/hpl/jena/sparql/engine/main/iterator/QueryIterUnion.java	(revision 6629)
+++ src/com/hp/hpl/jena/sparql/engine/main/iterator/QueryIterUnion.java	(working copy)
@@ -14,6 +14,7 @@
 import com.hp.hpl.jena.sparql.engine.binding.Binding;
 import com.hp.hpl.jena.sparql.engine.iterator.QueryIterConcat;
 import com.hp.hpl.jena.sparql.engine.iterator.QueryIterRepeatApply;
+import com.hp.hpl.jena.sparql.engine.iterator.QueryIterRoot;
 import com.hp.hpl.jena.sparql.engine.iterator.QueryIterSingleton;
 import com.hp.hpl.jena.sparql.engine.main.QC;
 import com.hp.hpl.jena.sparql.serializer.SerializationContext;
@@ -46,6 +47,7 @@
         {
             subOp = QC.substitute(subOp, binding) ;
             QueryIterator parent = new QueryIterSingleton(binding, getExecContext()) ;
+//            QueryIterator parent = QueryIterRoot.create(binding, getExecContext()); // Singleton(binding, getExecContext()) ;
             QueryIterator qIter = QC.execute(subOp, parent, getExecContext()) ;
             unionQIter.add(qIter) ;
         }
Index: src/com/hp/hpl/jena/query/Query.java
===================================================================
--- src/com/hp/hpl/jena/query/Query.java	(revision 6629)
+++ src/com/hp/hpl/jena/query/Query.java	(working copy)
@@ -16,6 +16,7 @@
 
 import com.hp.hpl.jena.graph.Node;
 import com.hp.hpl.jena.sparql.ARQConstants;
+import com.hp.hpl.jena.sparql.algebra.table.TableN;
 import com.hp.hpl.jena.sparql.core.Prologue;
 import com.hp.hpl.jena.sparql.core.QueryCompare;
 import com.hp.hpl.jena.sparql.core.QueryHashCode;
@@ -52,14 +53,14 @@
 public class Query extends Prologue implements Cloneable
 {
     static { ARQ.init() ; /* Ensure everything has started properly */ }
-    
+ 
     public static final int QueryTypeUnknown    = -123 ;
     public static final int QueryTypeSelect     = 111 ;
     public static final int QueryTypeConstruct  = 222 ;
     public static final int QueryTypeDescribe   = 333 ;
     public static final int QueryTypeAsk        = 444 ;
     int queryType = QueryTypeUnknown ; 
-    
+
     // If no model is provided explicitly, the query engine will load
     // a model from the URL.  Never a list of zero items.
     
@@ -82,7 +83,7 @@
     public static final int ORDER_ASCENDING           = 1 ; 
     public static final int ORDER_DESCENDING          = -1 ;
     public static final int ORDER_DEFAULT             = -2 ;    // Not explicitly given. 
-    public static final int ORDER_UNKNOW              = -3 ; 
+    public static final int ORDER_UNKNOW              = -3 ;
 
     boolean strictQuery = true ;
     
@@ -99,6 +100,17 @@
     // Any URIs/QNames in the DESCRIBE clause
     // Also uses resultVars
     protected List<Node> resultNodes               = new ArrayList<Node>() ;     // Type in list: Node
+ 
+    // AndyL:
+    // DESCRIBE MODES
+    public static final int DESCRIBE_NORMAL = 0;
+    public static final int DESCRIBE_SELF = 1; 
+    public static final int DESCRIBE_DATASET = 2; 
+    
+    private int describeMode = 0;
+    private boolean explainFlag = false;
+    
+    private TableN bindings = null;
     
     public Query()
     {
@@ -762,6 +774,30 @@
     {
         Serializer.serialize(this, writer, outSyntax) ;
     }
+
+	public void setExplainFlag() {
+		explainFlag = true;
+	}
+	
+	public boolean isExplainQuery() {
+		return explainFlag;
+	}
+
+	public void setDescribeMode(int mode) {
+		describeMode = mode;
+	}
+	
+	public int getDescribeMode() {
+		return describeMode;
+	}
+	
+	public void setInitialBindingTable(TableN t) {
+		bindings = t;
+	}
+	
+	public TableN getInitialBindingTable() {
+		return bindings;
+	}
 }
 
 /*
Index: Vocabularies/sparql-explain.ttl
===================================================================
--- Vocabularies/sparql-explain.ttl	(revision 0)
+++ Vocabularies/sparql-explain.ttl	(revision 0)
@@ -0,0 +1,93 @@
+@prefix rdf:     <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
+@prefix rdfs:    <http://www.w3.org/2000/01/rdf-schema#> .
+@prefix xsd:     <http://www.w3.org/2000/10/XMLSchema#> .
+@prefix spx:     <http://purl.org/NET/sparql-explain#> . # TODO register PURL and publish
+@prefix sp:      <http://spinrdf.org/sp> .
+
+# vocabulary for SPARQL EXPLAIN query results
+
+spx:QueryExplanation a rdfs:Class ;
+   rdfs:label "SPARQL Query Explanation" ;
+   rdfs:comment "Explanation of a SPARQL query." ;
+.
+
+spx:queryString a rdf:Property ;
+   rdfs:label "SPARQL query string" ;
+   rdfs:domain spx:QueryExplanation ;
+   rdfs:range xsd:string ;
+.
+
+spx:querySyntax a rdf:Property ;
+   rdfs:label "SPARQL query in SPIN representation" ;
+   rdfs:domain spx:QueryExplanation ;
+   rdfs:range sp:Element ; # s SPIN top-level query element
+.
+
+spx:expectedSolutions a rdf:Property ;
+   rdfs:label "expected query solutions" ;
+   rdfs:comment "the estimated number of query solutions (should be provided by implementations)" ;
+   rdfs:domain spx:QueryExplanation ;
+   rdfs:range xsd:int ;
+.
+
+spx:minSolutions a rdf:Property ;
+   rdfs:label "min query solutions" ;
+   rdfs:comment "guaranteed lower bound, if 0 there may be no solutions at all, if omitted clients should assume 0" ;
+   rdfs:domain spx:QueryExplanation ;
+   rdfs:range xsd:int ;
+.
+
+spx:maxSolutions a rdf:Property ;
+   rdfs:label "max query solutions" ;
+   rdfs:comment "guaranteed upper bound, if 0 there are no solutions at all, if omitted clients should assume positive infinity" ;
+   rdfs:domain spx:QueryExplanation ;
+   rdfs:range xsd:int ;
+.
+
+spx:expectedTriples a rdf:Property ;
+   rdfs:label "expected triples" ;
+   rdfs:comment "the estimated number of triples (should be provided by implementations)" ;
+   rdfs:domain spx:QueryExplanation ;
+   rdfs:range xsd:int ;
+.
+
+spx:minTriples a rdf:Property ;
+   rdfs:label "min triples" ;
+   rdfs:comment "guaranteed lower bound, if 0 there may be no triples returned at all, if omitted clients should assume 0" ;
+   rdfs:domain spx:QueryExplanation ;
+   rdfs:range xsd:int ;
+.
+
+spx:maxTriples a rdf:Property ;
+   rdfs:label "max triples" ;
+   rdfs:comment "guaranteed upper bound, if 0 no triples are returned at all, if omitted clients should assume positive infinity" ;
+   rdfs:domain spx:QueryExplanation ;
+   rdfs:range xsd:int ;
+.
+
+spx:timeTotal a rdf:Property ;
+   rdfs:label "total execution time [milliseconds]" ;
+   rdfs:comment "total execution time in milliseconds for processing and blind iteration of results, excluding transfer; ~= timeToFirst + (expectedSolutions-1)*timeToNext" ;
+   rdfs:domain spx:QueryExplanation ;
+   rdfs:range xsd:int ;
+.
+
+spx:timeToFirst a rdf:Property ;
+   rdfs:label "latency to first result [milliseconds]" ;
+   rdfs:comment "latency in milliseconds until the first result will be available, excluding transfer" ;
+   rdfs:domain spx:QueryExplanation ;
+   rdfs:range xsd:int ;
+.
+
+spx:timeToNext a rdf:Property ;
+   rdfs:label "latency to next result [milliseconds]" ;
+   rdfs:comment "latency in milliseconds until subsequent results are available, excluding transfer" ;
+   rdfs:domain spx:QueryExplanation ;
+   rdfs:range xsd:int ;
+.
+
+spx:plan a rdf:Property ;
+   rdfs:label "query plan details" ;
+   rdfs:comment "implementation-specific details for the query plan (typically as a string)" ;
+   rdfs:domain spx:QueryExplanation ;
+.
Index: src/com/hp/hpl/jena/sparql/algebra/opt/Optimize.java
===================================================================
--- src/com/hp/hpl/jena/sparql/algebra/opt/Optimize.java	(revision 6629)
+++ src/com/hp/hpl/jena/sparql/algebra/opt/Optimize.java	(working copy)
@@ -85,17 +85,23 @@
         op = apply("Property Functions", new TransformPropertyFunction(context), op) ;
         op = apply("Break up conjunctions", new TransformFilterImprove(), op) ;
 
+        // push filters down before BGP (applied top-down) => also increases chances to apply Filter Equality
+        op = FilterPushdown.apply(op);
+// done by pushdown already       op = apply("Flatten subsequent filters", new TransformFlattenFilters(), op) ;
+        
         // TODO Improve filter placement to go through assigns that have no effect.
         // Do this before filter placement and other sequence generating transformations.
-        // or improve to place in a sequence. 
+        // or improve to place in a sequence.
 
         op = apply("Filter Equality", new TransformEqualityFilter(), op) ;
         
         if ( context.isTrueOrUndef(ARQ.filterPlacement) )
-            // This can be done too early (breaks up BGPs).
-            op = apply("Filter Placement", new TransformFilterPlacement(), op) ;
+        // This can be done too early (breaks up BGPs).
+        op = apply("Filter Placement", new TransformFilterPlacement(), op) ;
         
         op = apply("Join strategy", new TransformJoinStrategy(context), op) ;
+        op = apply("Conditional Join", new TransformThetaJoins(), op);
+        
         op = apply("Path flattening", new TransformPathFlattern(), op) ;
         // Mark
         if ( false )
Index: build-vocab.xml
===================================================================
--- build-vocab.xml	(revision 0)
+++ build-vocab.xml	(revision 0)
@@ -0,0 +1,41 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project name="sparql-explain" default="vocab.spx" basedir=".">
+	<property name="name" location="location"/>
+	
+<!-- properties for source and target directories -->
+	
+	<property name="lib.dir" value="lib" />
+		
+<!-- ############### build targets ############### -->
+
+	<target name="compose-classpath">
+	    <path id="classpath">
+	    	<fileset dir="${lib.dir}">
+	    	    <include name="**/*.jar"/>
+	    	</fileset>
+		</path>
+		<pathconvert property="classpath" refid="classpath" pathsep=" " dirsep="/" />		
+	</target>
+	
+<!-- Section: vocabulary generation -->
+	
+  <target name="vocab.spx" depends="compose-classpath">
+    <java classname="jena.schemagen" classpathref="classpath" fork="yes" failonerror="true">
+      <arg value="--rdfs" />
+      <arg value="-e" />
+      <arg value="N3" />
+      <arg value="-i" />
+      <arg value="file:Vocabularies/sparql-explain.ttl" />
+      <arg value="-o" />
+      <arg value="src/com/hp/hpl/jena/sparql/vocabulary/SparqlExplainVocab.java" />
+      <arg value="--package" />
+      <arg value="com.hp.hpl.jena.sparql.vocabulary" />
+      <arg value="-a" />
+      <arg value="http://purl.org/NET/sparql-explain#" />
+      <arg value="-n" />
+	  <arg value="SparqlExplainVocab" />
+    </java>
+  </target>
+
+</project>
Index: src/com/hp/hpl/jena/sparql/engine/main/iterator/QueryIterService.java
===================================================================
--- src/com/hp/hpl/jena/sparql/engine/main/iterator/QueryIterService.java	(revision 6629)
+++ src/com/hp/hpl/jena/sparql/engine/main/iterator/QueryIterService.java	(working copy)
@@ -6,6 +6,9 @@
 
 package com.hp.hpl.jena.sparql.engine.main.iterator;
 
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 import com.hp.hpl.jena.sparql.algebra.Op;
 import com.hp.hpl.jena.sparql.algebra.op.OpService;
 import com.hp.hpl.jena.sparql.engine.ExecutionContext;
@@ -19,6 +22,7 @@
 
 public class QueryIterService extends QueryIterRepeatApply
 {
+	private static final Logger log = LoggerFactory.getLogger(QueryIterService.class);
     OpService opService ;
     
     public QueryIterService(QueryIterator input, OpService opService, ExecutionContext context)
@@ -30,12 +34,17 @@
     @Override
     protected QueryIterator nextStage(Binding outerBinding)
     {
-        Op op = QC.substitute(opService, outerBinding) ;
-        QueryIterator qIter = Service.exec((OpService)op) ;
-        // Need to put the outerBinding as parent to every binding of the service call.
-        // There should be no variables in common because of the OpSubstitute.substitute 
-        QueryIterator qIter2 = new QueryIterCommonParent(qIter, outerBinding, getExecContext()) ;
-        return qIter2 ;
+    	Op op = QC.substitute(opService, outerBinding) ;
+    	try {
+	        QueryIterator qIter = Service.exec((OpService)op) ;
+	        // Need to put the outerBinding as parent to every binding of the service call.
+	        // There should be no variables in common because of the OpSubstitute.substitute 
+	        QueryIterator qIter2 = new QueryIterCommonParent(qIter, outerBinding, getExecContext()) ;
+	        return qIter2 ;
+    	} catch (Exception e) {
+    		log.error("Error during query processing. Ignoring any data from endpoint <" + opService.getService().getURI() + ">.", e);
+    		return null;
+    	}
     }
 }
  
Index: src/com/hp/hpl/jena/sparql/lang/arq/ParseException.java
===================================================================
--- src/com/hp/hpl/jena/sparql/lang/arq/ParseException.java	(revision 6629)
+++ src/com/hp/hpl/jena/sparql/lang/arq/ParseException.java	(working copy)
@@ -101,7 +101,7 @@
    * of the final stack trace, and hence the correct error message
    * gets displayed.
    */
-  @Override public String getMessage() {
+  public String getMessage() {
     if (!specialConstructor) {
       return super.getMessage();
     }
@@ -131,7 +131,7 @@
       retval += " \"";
       retval += add_escapes(tok.image);
       retval += " \"";
-      tok = tok.next;
+      tok = tok.next; 
     }
     retval += "\" at line " + currentToken.next.beginLine + ", column " + currentToken.next.beginColumn;
     retval += "." + eol;
@@ -148,7 +148,7 @@
    * The end of line string for this machine.
    */
   protected String eol = System.getProperty("line.separator", "\n");
-
+ 
   /**
    * Used to convert raw characters to their escaped version
    * when these raw version cannot be used as part of an ASCII
@@ -200,4 +200,4 @@
    }
 
 }
-/* JavaCC - OriginalChecksum=8f471b0100e98c0e2650ef79c9b6dfa3 (do not edit this line) */
+/* JavaCC - OriginalChecksum=1a81efba0b75b84b5080cae65d3ca85f (do not edit this line) */
Index: src/com/hp/hpl/jena/query/QueryExecution.java
===================================================================
--- src/com/hp/hpl/jena/query/QueryExecution.java	(revision 6629)
+++ src/com/hp/hpl/jena/query/QueryExecution.java	(working copy)
@@ -71,7 +71,10 @@
     /** Execute an ASK query */
     public boolean execAsk();
     
-	/** Stop in mid execution.
+    /** by AndyL: execute EXPLAIN ASK|SELECT|DESCRIBE|CONSTRUCT query */
+    public Model execExplain();
+
+    /** Stop in mid execution.
 	 *  No guarantee that the concrete implementation actual
      *  will stop or that it will do so immediately.
      *  No operations on the query execution or any associated
@@ -89,6 +92,7 @@
      *  result set are permitted after this call.
      */
 	public void close();
+
     
 //    /** Say whether this QueryExecution is useable or not.
 //     * May not be supported or meaningful for all QueryExecution implementations.
Index: src/com/hp/hpl/jena/sparql/lang/arq/ARQParser.java
===================================================================
--- src/com/hp/hpl/jena/sparql/lang/arq/ARQParser.java	(revision 6629)
+++ src/com/hp/hpl/jena/sparql/lang/arq/ARQParser.java	(working copy)
@@ -6,15 +6,21 @@
 
 package com.hp.hpl.jena.sparql.lang.arq ;
 
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
 import com.hp.hpl.jena.graph.* ;
 import com.hp.hpl.jena.query.* ;
+import com.hp.hpl.jena.sparql.algebra.table.TableN;
 import com.hp.hpl.jena.sparql.core.Var ;
 import com.hp.hpl.jena.sparql.syntax.* ;
 import com.hp.hpl.jena.sparql.expr.* ;
 import com.hp.hpl.jena.sparql.path.* ;
 
 import com.hp.hpl.jena.sparql.expr.aggregate.* ;
-
+import com.hp.hpl.jena.sparql.engine.binding.Binding;
+import com.hp.hpl.jena.sparql.engine.binding.BindingMap;
 
 import com.hp.hpl.jena.sparql.modify.op.* ;
 
@@ -32,6 +38,15 @@
   final public void Query() throws ParseException {
     Prologue();
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case EXPLAIN:
+      jj_consume_token(EXPLAIN);
+                getQuery().setExplainFlag();
+      break;
+    default:
+      jj_la1[0] = jj_gen;
+      ;
+    }
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
     case SELECT:
       SelectQuery();
       break;
@@ -45,7 +60,7 @@
       AskQuery();
       break;
     default:
-      jj_la1[0] = jj_gen;
+      jj_la1[1] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -57,7 +72,7 @@
       BaseDecl();
       break;
     default:
-      jj_la1[1] = jj_gen;
+      jj_la1[2] = jj_gen;
       ;
     }
     label_1:
@@ -67,7 +82,7 @@
         ;
         break;
       default:
-        jj_la1[2] = jj_gen;
+        jj_la1[3] = jj_gen;
         break label_1;
       }
       PrefixDecl();
@@ -108,13 +123,13 @@
                 getQuery().setReduced(true);
         break;
       default:
-        jj_la1[3] = jj_gen;
+        jj_la1[4] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
       break;
     default:
-      jj_la1[4] = jj_gen;
+      jj_la1[5] = jj_gen;
       ;
     }
     allowAggregatesInExpressions = true ;
@@ -183,7 +198,7 @@
             v = Var();
             break;
           default:
-            jj_la1[5] = jj_gen;
+            jj_la1[6] = jj_gen;
             ;
           }
           jj_consume_token(RPAREN);
@@ -191,7 +206,7 @@
       getQuery().setQueryResultStar(false) ;
           break;
         default:
-          jj_la1[6] = jj_gen;
+          jj_la1[7] = jj_gen;
           jj_consume_token(-1);
           throw new ParseException();
         }
@@ -218,7 +233,7 @@
           ;
           break;
         default:
-          jj_la1[7] = jj_gen;
+          jj_la1[8] = jj_gen;
           break label_2;
         }
       }
@@ -228,7 +243,7 @@
              getQuery().setQueryResultStar(true) ;
       break;
     default:
-      jj_la1[8] = jj_gen;
+      jj_la1[9] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -240,15 +255,171 @@
         ;
         break;
       default:
-        jj_la1[9] = jj_gen;
+        jj_la1[10] = jj_gen;
         break label_3;
       }
       DatasetClause();
     }
     WhereClause();
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case BINDINGS:
+      jj_consume_token(BINDINGS);
+      Bindings();
+      break;
+    default:
+      jj_la1[11] = jj_gen;
+      ;
+    }
     SolutionModifier();
   }
 
+  final public void Bindings() throws ParseException {
+        TableN t = new TableN();
+        List<Var> vars = new ArrayList<Var>();
+        Var v;
+        Iterator<Var> vIt;
+        Var next;
+        Node n;
+        Binding b = null;
+    label_4:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case VAR1:
+      case VAR2:
+        ;
+        break;
+      default:
+        jj_la1[12] = jj_gen;
+        break label_4;
+      }
+      v = Var();
+                      vars.add(v);
+    }
+    jj_consume_token(LBRACE);
+    label_5:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case IRIref:
+      case PNAME_NS:
+      case PNAME_LN:
+      case BLANK_NODE_LABEL:
+      case VAR1:
+      case VAR2:
+      case TRUE:
+      case FALSE:
+      case INTEGER:
+      case DECIMAL:
+      case DOUBLE:
+      case INTEGER_POSITIVE:
+      case DECIMAL_POSITIVE:
+      case DOUBLE_POSITIVE:
+      case INTEGER_NEGATIVE:
+      case DECIMAL_NEGATIVE:
+      case DOUBLE_NEGATIVE:
+      case STRING_LITERAL1:
+      case STRING_LITERAL2:
+      case STRING_LITERAL_LONG1:
+      case STRING_LITERAL_LONG2:
+      case NIL:
+      case ANON:
+      case DOT:
+      case NULL:
+        ;
+        break;
+      default:
+        jj_la1[13] = jj_gen;
+        break label_5;
+      }
+                  b = new BindingMap(); vIt = vars.iterator();
+      label_6:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case IRIref:
+        case PNAME_NS:
+        case PNAME_LN:
+        case BLANK_NODE_LABEL:
+        case VAR1:
+        case VAR2:
+        case TRUE:
+        case FALSE:
+        case INTEGER:
+        case DECIMAL:
+        case DOUBLE:
+        case INTEGER_POSITIVE:
+        case DECIMAL_POSITIVE:
+        case DOUBLE_POSITIVE:
+        case INTEGER_NEGATIVE:
+        case DECIMAL_NEGATIVE:
+        case DOUBLE_NEGATIVE:
+        case STRING_LITERAL1:
+        case STRING_LITERAL2:
+        case STRING_LITERAL_LONG1:
+        case STRING_LITERAL_LONG2:
+        case NIL:
+        case ANON:
+        case NULL:
+          ;
+          break;
+        default:
+          jj_la1[14] = jj_gen;
+          break label_6;
+        }
+                                if (vIt.hasNext())
+                                        next = vIt.next();
+                                else
+                                        {if (true) throw new Error("Invalid initial binding: too few variables for binding.");}
+        n = NullVarOrNode();
+                          if (n != null)
+                                b.add(next, n);
+      }
+      jj_consume_token(DOT);
+                  t.addBinding(b);
+    }
+    jj_consume_token(RBRACE);
+          getQuery().setInitialBindingTable(t);
+  }
+
+  final public Node NullVarOrNode() throws ParseException {
+                         Node n;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case NULL:
+      jj_consume_token(NULL);
+                   n = null;
+      break;
+    case IRIref:
+    case PNAME_NS:
+    case PNAME_LN:
+    case BLANK_NODE_LABEL:
+    case VAR1:
+    case VAR2:
+    case TRUE:
+    case FALSE:
+    case INTEGER:
+    case DECIMAL:
+    case DOUBLE:
+    case INTEGER_POSITIVE:
+    case DECIMAL_POSITIVE:
+    case DOUBLE_POSITIVE:
+    case INTEGER_NEGATIVE:
+    case DECIMAL_NEGATIVE:
+    case DOUBLE_NEGATIVE:
+    case STRING_LITERAL1:
+    case STRING_LITERAL2:
+    case STRING_LITERAL_LONG1:
+    case STRING_LITERAL_LONG2:
+    case NIL:
+    case ANON:
+      n = VarOrTerm();
+      break;
+    default:
+      jj_la1[15] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+          {if (true) return n;}
+    throw new Error("Missing return statement in function");
+  }
+
   final public void ConstructQuery() throws ParseException {
                           Template t ;
     jj_consume_token(CONSTRUCT);
@@ -256,15 +427,15 @@
     t = ConstructTemplate();
       getQuery().setQueryResultStar(false) ;
       getQuery().setConstructTemplate(t) ;
-    label_4:
+    label_7:
     while (true) {
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case FROM:
         ;
         break;
       default:
-        jj_la1[10] = jj_gen;
-        break label_4;
+        jj_la1[16] = jj_gen;
+        break label_7;
       }
       DatasetClause();
     }
@@ -277,75 +448,108 @@
     jj_consume_token(DESCRIBE);
       getQuery().setQueryDescribeType() ;
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case SELF:
+    case SERVICE:
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case SERVICE:
+        jj_consume_token(SERVICE);
+        break;
+      case SELF:
+        jj_consume_token(SELF);
+        break;
+      default:
+        jj_la1[17] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+            getQuery().setDescribeMode(Query.DESCRIBE_SELF);
+      break;
+    case DATASET:
+      jj_consume_token(DATASET);
+        getQuery().setDescribeMode(Query.DESCRIBE_DATASET);
+      break;
     case IRIref:
     case PNAME_NS:
     case PNAME_LN:
     case VAR1:
     case VAR2:
-      label_5:
+    case STAR:
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case IRIref:
+      case PNAME_NS:
+      case PNAME_LN:
+      case VAR1:
+      case VAR2:
+        label_8:
+        while (true) {
+          n = VarOrIRIref();
+                            getQuery().addDescribeNode(n) ;
+          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+          case IRIref:
+          case PNAME_NS:
+          case PNAME_LN:
+          case VAR1:
+          case VAR2:
+            ;
+            break;
+          default:
+            jj_la1[18] = jj_gen;
+            break label_8;
+          }
+        }
+        getQuery().setQueryResultStar(false) ;
+        break;
+      case STAR:
+        jj_consume_token(STAR);
+        getQuery().setQueryResultStar(true) ;
+        break;
+      default:
+        jj_la1[19] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      label_9:
       while (true) {
-        n = VarOrIRIref();
-                          getQuery().addDescribeNode(n) ;
         switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-        case IRIref:
-        case PNAME_NS:
-        case PNAME_LN:
-        case VAR1:
-        case VAR2:
+        case FROM:
           ;
           break;
         default:
-          jj_la1[11] = jj_gen;
-          break label_5;
+          jj_la1[20] = jj_gen;
+          break label_9;
         }
+        DatasetClause();
       }
-      getQuery().setQueryResultStar(false) ;
-      break;
-    case STAR:
-      jj_consume_token(STAR);
-      getQuery().setQueryResultStar(true) ;
-      break;
-    default:
-      jj_la1[12] = jj_gen;
-      jj_consume_token(-1);
-      throw new ParseException();
-    }
-    label_6:
-    while (true) {
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case FROM:
-        ;
+      case WHERE:
+      case LBRACE:
+        WhereClause();
         break;
       default:
-        jj_la1[13] = jj_gen;
-        break label_6;
+        jj_la1[21] = jj_gen;
+        ;
       }
-      DatasetClause();
-    }
-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case WHERE:
-    case LBRACE:
-      WhereClause();
+      SolutionModifier();
       break;
     default:
-      jj_la1[14] = jj_gen;
-      ;
+      jj_la1[22] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
     }
-    SolutionModifier();
   }
 
   final public void AskQuery() throws ParseException {
     jj_consume_token(ASK);
           getQuery().setQueryAskType() ;
-    label_7:
+    label_10:
     while (true) {
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case FROM:
         ;
         break;
       default:
-        jj_la1[15] = jj_gen;
-        break label_7;
+        jj_la1[23] = jj_gen;
+        break label_10;
       }
       DatasetClause();
     }
@@ -365,7 +569,7 @@
       NamedGraphClause();
       break;
     default:
-      jj_la1[16] = jj_gen;
+      jj_la1[24] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -400,7 +604,7 @@
       jj_consume_token(WHERE);
       break;
     default:
-      jj_la1[17] = jj_gen;
+      jj_la1[25] = jj_gen;
       ;
     }
     el = GroupGraphPattern();
@@ -413,7 +617,7 @@
       GroupClause();
       break;
     default:
-      jj_la1[18] = jj_gen;
+      jj_la1[26] = jj_gen;
       ;
     }
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
@@ -421,7 +625,7 @@
       HavingClause();
       break;
     default:
-      jj_la1[19] = jj_gen;
+      jj_la1[27] = jj_gen;
       ;
     }
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
@@ -429,7 +633,7 @@
       OrderClause();
       break;
     default:
-      jj_la1[20] = jj_gen;
+      jj_la1[28] = jj_gen;
       ;
     }
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
@@ -438,7 +642,7 @@
       LimitOffsetClauses();
       break;
     default:
-      jj_la1[21] = jj_gen;
+      jj_la1[29] = jj_gen;
       ;
     }
   }
@@ -446,7 +650,7 @@
   final public void GroupClause() throws ParseException {
     jj_consume_token(GROUP);
     jj_consume_token(BY);
-    label_8:
+    label_11:
     while (true) {
       GroupCondition();
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
@@ -470,8 +674,8 @@
         ;
         break;
       default:
-        jj_la1[22] = jj_gen;
-        break label_8;
+        jj_la1[30] = jj_gen;
+        break label_11;
       }
     }
   }
@@ -508,7 +712,7 @@
         v = Var();
         break;
       default:
-        jj_la1[23] = jj_gen;
+        jj_la1[31] = jj_gen;
         ;
       }
       jj_consume_token(RPAREN);
@@ -520,7 +724,7 @@
       getQuery().addGroupBy(v) ;
       break;
     default:
-      jj_la1[24] = jj_gen;
+      jj_la1[32] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -529,7 +733,7 @@
   final public void HavingClause() throws ParseException {
       allowAggregatesInExpressions = true ;
     jj_consume_token(HAVING);
-    label_9:
+    label_12:
     while (true) {
       HavingCondition();
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
@@ -551,8 +755,8 @@
         ;
         break;
       default:
-        jj_la1[25] = jj_gen;
-        break label_9;
+        jj_la1[33] = jj_gen;
+        break label_12;
       }
     }
       allowAggregatesInExpressions = false ;
@@ -567,7 +771,7 @@
   final public void OrderClause() throws ParseException {
     jj_consume_token(ORDER);
     jj_consume_token(BY);
-    label_10:
+    label_13:
     while (true) {
       OrderCondition();
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
@@ -593,8 +797,8 @@
         ;
         break;
       default:
-        jj_la1[26] = jj_gen;
-        break label_10;
+        jj_la1[34] = jj_gen;
+        break label_13;
       }
     }
   }
@@ -615,7 +819,7 @@
                  direction = Query.ORDER_DESCENDING ;
         break;
       default:
-        jj_la1[27] = jj_gen;
+        jj_la1[35] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
@@ -661,13 +865,13 @@
         v = Var();
         break;
       default:
-        jj_la1[28] = jj_gen;
+        jj_la1[36] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
       break;
     default:
-      jj_la1[29] = jj_gen;
+      jj_la1[37] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -686,7 +890,7 @@
         OffsetClause();
         break;
       default:
-        jj_la1[30] = jj_gen;
+        jj_la1[38] = jj_gen;
         ;
       }
       break;
@@ -697,12 +901,12 @@
         LimitClause();
         break;
       default:
-        jj_la1[31] = jj_gen;
+        jj_la1[39] = jj_gen;
         ;
       }
       break;
     default:
-      jj_la1[32] = jj_gen;
+      jj_la1[40] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -725,7 +929,7 @@
 // ---- SPARQL/Update
   final public void UpdateUnit() throws ParseException {
     Prologue();
-    label_11:
+    label_14:
     while (true) {
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case MODIFY:
@@ -738,8 +942,8 @@
         ;
         break;
       default:
-        jj_la1[33] = jj_gen;
-        break label_11;
+        jj_la1[41] = jj_gen;
+        break label_14;
       }
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case MODIFY:
@@ -754,7 +958,7 @@
         Manage();
         break;
       default:
-        jj_la1[34] = jj_gen;
+        jj_la1[42] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
@@ -781,7 +985,7 @@
       up = Clear();
       break;
     default:
-      jj_la1[35] = jj_gen;
+      jj_la1[43] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -791,15 +995,15 @@
   final public UpdateModify Modify() throws ParseException {
   UpdateModify up = new UpdateModify() ; String iri ; Template template ; Element el ;
     jj_consume_token(MODIFY);
-    label_12:
+    label_15:
     while (true) {
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case GRAPH:
         ;
         break;
       default:
-        jj_la1[36] = jj_gen;
-        break label_12;
+        jj_la1[44] = jj_gen;
+        break label_15;
       }
       iri = GraphIRI();
                          up.addGraphName(iri) ;
@@ -817,7 +1021,7 @@
                              up.setPattern(el) ;
       break;
     default:
-      jj_la1[37] = jj_gen;
+      jj_la1[45] = jj_gen;
       ;
     }
       {if (true) return up ;}
@@ -839,7 +1043,7 @@
       up = DeleteTemplate();
       break;
     default:
-      jj_la1[38] = jj_gen;
+      jj_la1[46] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -852,7 +1056,7 @@
   String iri ; Template template ;
   Token t ;
     t = jj_consume_token(DATA);
-    label_13:
+    label_16:
     while (true) {
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case IRIref:
@@ -862,15 +1066,15 @@
         ;
         break;
       default:
-        jj_la1[39] = jj_gen;
-        break label_13;
+        jj_la1[47] = jj_gen;
+        break label_16;
       }
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case FROM:
         jj_consume_token(FROM);
         break;
       default:
-        jj_la1[40] = jj_gen;
+        jj_la1[48] = jj_gen;
         ;
       }
       iri = IRIref();
@@ -886,7 +1090,7 @@
 
   final public Update DeleteTemplate() throws ParseException {
   UpdateDelete up = new UpdateDelete() ; String iri ; Template template ; Element el ;
-    label_14:
+    label_17:
     while (true) {
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case IRIref:
@@ -896,15 +1100,15 @@
         ;
         break;
       default:
-        jj_la1[41] = jj_gen;
-        break label_14;
+        jj_la1[49] = jj_gen;
+        break label_17;
       }
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case FROM:
         jj_consume_token(FROM);
         break;
       default:
-        jj_la1[42] = jj_gen;
+        jj_la1[50] = jj_gen;
         ;
       }
       iri = IRIref();
@@ -919,7 +1123,7 @@
                              up.setPattern(el) ;
       break;
     default:
-      jj_la1[43] = jj_gen;
+      jj_la1[51] = jj_gen;
       ;
     }
       {if (true) return up ;}
@@ -941,7 +1145,7 @@
       up = InsertTemplate();
       break;
     default:
-      jj_la1[44] = jj_gen;
+      jj_la1[52] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -954,7 +1158,7 @@
   String iri ; Template template ;
   Token t ;
     t = jj_consume_token(DATA);
-    label_15:
+    label_18:
     while (true) {
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case IRIref:
@@ -964,15 +1168,15 @@
         ;
         break;
       default:
-        jj_la1[45] = jj_gen;
-        break label_15;
+        jj_la1[53] = jj_gen;
+        break label_18;
       }
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case INTO:
         jj_consume_token(INTO);
         break;
       default:
-        jj_la1[46] = jj_gen;
+        jj_la1[54] = jj_gen;
         ;
       }
       iri = IRIref();
@@ -988,7 +1192,7 @@
 
   final public UpdatePattern InsertTemplate() throws ParseException {
   UpdateInsert up = new UpdateInsert() ; String iri ; Template template ; Element el ;
-    label_16:
+    label_19:
     while (true) {
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case IRIref:
@@ -998,15 +1202,15 @@
         ;
         break;
       default:
-        jj_la1[47] = jj_gen;
-        break label_16;
+        jj_la1[55] = jj_gen;
+        break label_19;
       }
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case INTO:
         jj_consume_token(INTO);
         break;
       default:
-        jj_la1[48] = jj_gen;
+        jj_la1[56] = jj_gen;
         ;
       }
       iri = IRIref();
@@ -1021,7 +1225,7 @@
                              up.setPattern(el) ;
       break;
     default:
-      jj_la1[49] = jj_gen;
+      jj_la1[57] = jj_gen;
       ;
     }
       {if (true) return up ;}
@@ -1039,7 +1243,7 @@
   final public UpdateLoad Load() throws ParseException {
                       UpdateLoad up = new UpdateLoad() ; String iri ;
     jj_consume_token(LOAD);
-    label_17:
+    label_20:
     while (true) {
       iri = IRIref();
                               up.addLoadIRI(iri) ;
@@ -1050,8 +1254,8 @@
         ;
         break;
       default:
-        jj_la1[50] = jj_gen;
-        break label_17;
+        jj_la1[58] = jj_gen;
+        break label_20;
       }
     }
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
@@ -1061,7 +1265,7 @@
                              up.setGraphName(iri) ;
       break;
     default:
-      jj_la1[51] = jj_gen;
+      jj_la1[59] = jj_gen;
       ;
     }
       {if (true) return up ;}
@@ -1077,7 +1281,7 @@
                          up.setGraphName(iri) ;
       break;
     default:
-      jj_la1[52] = jj_gen;
+      jj_la1[60] = jj_gen;
       ;
     }
       {if (true) return up ;}
@@ -1094,7 +1298,7 @@
       mgt = Drop();
       break;
     default:
-      jj_la1[53] = jj_gen;
+      jj_la1[61] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -1110,7 +1314,7 @@
                 silent = true ;
       break;
     default:
-      jj_la1[54] = jj_gen;
+      jj_la1[62] = jj_gen;
       ;
     }
     iri = GraphIRI();
@@ -1127,7 +1331,7 @@
                silent = true ;
       break;
     default:
-      jj_la1[55] = jj_gen;
+      jj_la1[63] = jj_gen;
       ;
     }
     iri = GraphIRI();
@@ -1142,7 +1346,7 @@
       jj_consume_token(WHERE);
       break;
     default:
-      jj_la1[56] = jj_gen;
+      jj_la1[64] = jj_gen;
       ;
     }
     el = GroupGraphPattern();
@@ -1189,7 +1393,7 @@
       el = new ElementSubQuery(q) ;
       break;
     default:
-      jj_la1[57] = jj_gen;
+      jj_la1[65] = jj_gen;
       el = GroupGraphPatternSub();
     }
     jj_consume_token(RBRACE);
@@ -1233,10 +1437,10 @@
       elg.addElement(el) ;
       break;
     default:
-      jj_la1[58] = jj_gen;
+      jj_la1[66] = jj_gen;
       ;
     }
-    label_18:
+    label_21:
     while (true) {
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case GRAPH:
@@ -1249,8 +1453,8 @@
         ;
         break;
       default:
-        jj_la1[59] = jj_gen;
-        break label_18;
+        jj_la1[67] = jj_gen;
+        break label_21;
       }
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case GRAPH:
@@ -1265,7 +1469,7 @@
         el = Filter();
         break;
       default:
-        jj_la1[60] = jj_gen;
+        jj_la1[68] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
@@ -1275,7 +1479,7 @@
         jj_consume_token(DOT);
         break;
       default:
-        jj_la1[61] = jj_gen;
+        jj_la1[69] = jj_gen;
         ;
       }
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
@@ -1310,7 +1514,7 @@
         elg.addElement(el) ;
         break;
       default:
-        jj_la1[62] = jj_gen;
+        jj_la1[70] = jj_gen;
         ;
       }
     }
@@ -1357,12 +1561,12 @@
         TriplesBlock(acc);
         break;
       default:
-        jj_la1[63] = jj_gen;
+        jj_la1[71] = jj_gen;
         ;
       }
       break;
     default:
-      jj_la1[64] = jj_gen;
+      jj_la1[72] = jj_gen;
       ;
     }
       {if (true) return acc ;}
@@ -1393,7 +1597,7 @@
       el = FetchGraph();
       break;
     default:
-      jj_la1[65] = jj_gen;
+      jj_la1[73] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -1453,15 +1657,15 @@
   final public Element GroupOrUnionGraphPattern() throws ParseException {
   Element el = null ; ElementUnion el2 = null ;
     el = GroupGraphPattern();
-    label_19:
+    label_22:
     while (true) {
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case UNION:
         ;
         break;
       default:
-        jj_la1[66] = jj_gen;
-        break label_19;
+        jj_la1[74] = jj_gen;
+        break label_22;
       }
       jj_consume_token(UNION);
       if ( el2 == null )
@@ -1509,7 +1713,7 @@
       c = FunctionCall();
       break;
     default:
-      jj_la1[67] = jj_gen;
+      jj_la1[75] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -1535,15 +1739,15 @@
       jj_consume_token(LPAREN);
       expr = Expression();
                             args.add(expr) ;
-      label_20:
+      label_23:
       while (true) {
         switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
         case COMMA:
           ;
           break;
         default:
-          jj_la1[68] = jj_gen;
-          break label_20;
+          jj_la1[76] = jj_gen;
+          break label_23;
         }
         jj_consume_token(COMMA);
         expr = Expression();
@@ -1552,7 +1756,7 @@
       jj_consume_token(RPAREN);
       break;
     default:
-      jj_la1[69] = jj_gen;
+      jj_la1[77] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -1594,7 +1798,7 @@
       ConstructTriples(g);
       break;
     default:
-      jj_la1[70] = jj_gen;
+      jj_la1[78] = jj_gen;
       ;
     }
     jj_consume_token(RBRACE);
@@ -1605,12 +1809,12 @@
 
   final public void ConstructTriples(TemplateGroup acc) throws ParseException {
     TriplesSameSubject(acc);
-    label_21:
+    label_24:
     while (true) {
       if (jj_2_1(2)) {
         ;
       } else {
-        break label_21;
+        break label_24;
       }
       jj_consume_token(DOT);
       TriplesSameSubject(acc);
@@ -1620,7 +1824,7 @@
       jj_consume_token(DOT);
       break;
     default:
-      jj_la1[71] = jj_gen;
+      jj_la1[79] = jj_gen;
       ;
     }
   }
@@ -1663,7 +1867,7 @@
       PropertyList(s, acc);
       break;
     default:
-      jj_la1[72] = jj_gen;
+      jj_la1[80] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -1673,15 +1877,15 @@
       Node p = null ;
     p = Verb();
     ObjectList(s, p, null, acc);
-    label_22:
+    label_25:
     while (true) {
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case SEMICOLON:
         ;
         break;
       default:
-        jj_la1[73] = jj_gen;
-        break label_22;
+        jj_la1[81] = jj_gen;
+        break label_25;
       }
       jj_consume_token(SEMICOLON);
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
@@ -1695,7 +1899,7 @@
         ObjectList(s, p, null, acc);
         break;
       default:
-        jj_la1[74] = jj_gen;
+        jj_la1[82] = jj_gen;
         ;
       }
     }
@@ -1712,7 +1916,7 @@
       PropertyListNotEmpty(s, acc);
       break;
     default:
-      jj_la1[75] = jj_gen;
+      jj_la1[83] = jj_gen;
       ;
     }
   }
@@ -1720,15 +1924,15 @@
   final public void ObjectList(Node s, Node p, Path path, TripleCollector acc) throws ParseException {
                                                                    Node o ;
     Object(s, p, path, acc);
-    label_23:
+    label_26:
     while (true) {
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case COMMA:
         ;
         break;
       default:
-        jj_la1[76] = jj_gen;
-        break label_23;
+        jj_la1[84] = jj_gen;
+        break label_26;
       }
       jj_consume_token(COMMA);
       Object(s, p, path, acc);
@@ -1757,7 +1961,7 @@
                                  p = nRDFtype ;
       break;
     default:
-      jj_la1[77] = jj_gen;
+      jj_la1[85] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -1803,7 +2007,7 @@
       PropertyListPath(s, acc);
       break;
     default:
-      jj_la1[78] = jj_gen;
+      jj_la1[86] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -1825,20 +2029,20 @@
       p = VerbSimple();
       break;
     default:
-      jj_la1[79] = jj_gen;
+      jj_la1[87] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
     ObjectList(s, p, path, acc);
-    label_24:
+    label_27:
     while (true) {
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case SEMICOLON:
         ;
         break;
       default:
-        jj_la1[80] = jj_gen;
-        break label_24;
+        jj_la1[88] = jj_gen;
+        break label_27;
       }
       jj_consume_token(SEMICOLON);
       path = null ; p = null ;
@@ -1865,14 +2069,14 @@
           p = VerbSimple();
           break;
         default:
-          jj_la1[81] = jj_gen;
+          jj_la1[89] = jj_gen;
           jj_consume_token(-1);
           throw new ParseException();
         }
         ObjectList(s, p, path, acc);
         break;
       default:
-        jj_la1[82] = jj_gen;
+        jj_la1[90] = jj_gen;
         ;
       }
     }
@@ -1889,7 +2093,7 @@
       PropertyListNotEmpty(s, acc);
       break;
     default:
-      jj_la1[83] = jj_gen;
+      jj_la1[91] = jj_gen;
       ;
     }
   }
@@ -1940,7 +2144,7 @@
         {if (true) return new P_Alt(p1, p2) ;}
       break;
     default:
-      jj_la1[84] = jj_gen;
+      jj_la1[92] = jj_gen;
       ;
     }
      {if (true) return p1 ;}
@@ -1965,13 +2169,13 @@
         {if (true) return new P_Seq(p1, new P_Reverse(p2)) ;}
         break;
       default:
-        jj_la1[85] = jj_gen;
+        jj_la1[93] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
       break;
     default:
-      jj_la1[86] = jj_gen;
+      jj_la1[94] = jj_gen;
       ;
     }
      {if (true) return p1;}
@@ -1995,7 +2199,7 @@
        p = new P_Reverse(p) ;
       break;
     default:
-      jj_la1[87] = jj_gen;
+      jj_la1[95] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -2007,7 +2211,7 @@
       p = PathMod(p);
       break;
     default:
-      jj_la1[88] = jj_gen;
+      jj_la1[96] = jj_gen;
       ;
     }
      {if (true) return p ;}
@@ -2047,7 +2251,7 @@
                       {if (true) return new P_Mod(p, i1, i2) ;}
           break;
         default:
-          jj_la1[89] = jj_gen;
+          jj_la1[97] = jj_gen;
           jj_consume_token(-1);
           throw new ParseException();
         }
@@ -2057,13 +2261,13 @@
                        {if (true) return new P_Mod(p, i1) ;}
         break;
       default:
-        jj_la1[90] = jj_gen;
+        jj_la1[98] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
       break;
     default:
-      jj_la1[91] = jj_gen;
+      jj_la1[99] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -2089,7 +2293,7 @@
       jj_consume_token(RPAREN);
       break;
     default:
-      jj_la1[92] = jj_gen;
+      jj_la1[100] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -2120,7 +2324,7 @@
                                    {if (true) return n ;}
       break;
     default:
-      jj_la1[93] = jj_gen;
+      jj_la1[101] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -2140,7 +2344,7 @@
   final public Node Collection(TripleCollector acc) throws ParseException {
       Node listHead = nRDFnil ; Node lastCell = null ; int mark ; Node n ;
     jj_consume_token(LPAREN);
-    label_25:
+    label_28:
     while (true) {
       Node cell = createListNode() ;
       if ( listHead == nRDFnil )
@@ -2180,8 +2384,8 @@
         ;
         break;
       default:
-        jj_la1[94] = jj_gen;
-        break label_25;
+        jj_la1[102] = jj_gen;
+        break label_28;
       }
     }
     jj_consume_token(RPAREN);
@@ -2227,7 +2431,7 @@
                          {if (true) return n ;}
       break;
     default:
-      jj_la1[95] = jj_gen;
+      jj_la1[103] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -2265,7 +2469,7 @@
       n = GraphTerm();
       break;
     default:
-      jj_la1[96] = jj_gen;
+      jj_la1[104] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -2288,7 +2492,7 @@
                                  n = createNode(iri) ;
       break;
     default:
-      jj_la1[97] = jj_gen;
+      jj_la1[105] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -2306,7 +2510,7 @@
       t = jj_consume_token(VAR2);
       break;
     default:
-      jj_la1[98] = jj_gen;
+      jj_la1[106] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -2357,7 +2561,7 @@
           {if (true) return nRDFnil ;}
       break;
     default:
-      jj_la1[99] = jj_gen;
+      jj_la1[107] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -2375,15 +2579,15 @@
   final public Expr ConditionalOrExpression() throws ParseException {
                                    Expr expr1, expr2 ;
     expr1 = ConditionalAndExpression();
-    label_26:
+    label_29:
     while (true) {
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case SC_OR:
         ;
         break;
       default:
-        jj_la1[100] = jj_gen;
-        break label_26;
+        jj_la1[108] = jj_gen;
+        break label_29;
       }
       jj_consume_token(SC_OR);
       expr2 = ConditionalAndExpression();
@@ -2396,15 +2600,15 @@
   final public Expr ConditionalAndExpression() throws ParseException {
                                     Expr expr1, expr2 ;
     expr1 = ValueLogical();
-    label_27:
+    label_30:
     while (true) {
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case SC_AND:
         ;
         break;
       default:
-        jj_la1[101] = jj_gen;
-        break label_27;
+        jj_la1[109] = jj_gen;
+        break label_30;
       }
       jj_consume_token(SC_AND);
       expr2 = ValueLogical();
@@ -2463,13 +2667,13 @@
         expr1 = new E_GreaterThanOrEqual(expr1, expr2) ;
         break;
       default:
-        jj_la1[102] = jj_gen;
+        jj_la1[110] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
       break;
     default:
-      jj_la1[103] = jj_gen;
+      jj_la1[111] = jj_gen;
       ;
     }
       {if (true) return expr1 ;}
@@ -2486,7 +2690,7 @@
   final public Expr AdditiveExpression() throws ParseException {
                               Expr expr1, expr2, expr3 ; boolean addition ; Node n ;
     expr1 = MultiplicativeExpression();
-    label_28:
+    label_31:
     while (true) {
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case INTEGER_POSITIVE:
@@ -2500,8 +2704,8 @@
         ;
         break;
       default:
-        jj_la1[104] = jj_gen;
-        break label_28;
+        jj_la1[112] = jj_gen;
+        break label_31;
       }
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case PLUS:
@@ -2538,7 +2742,7 @@
          addition = false ;
           break;
         default:
-          jj_la1[105] = jj_gen;
+          jj_la1[113] = jj_gen;
           jj_consume_token(-1);
           throw new ParseException();
         }
@@ -2557,13 +2761,13 @@
                                             expr2 = new E_Divide(expr2, expr3) ;
             break;
           default:
-            jj_la1[106] = jj_gen;
+            jj_la1[114] = jj_gen;
             jj_consume_token(-1);
             throw new ParseException();
           }
           break;
         default:
-          jj_la1[107] = jj_gen;
+          jj_la1[115] = jj_gen;
           ;
         }
       if ( addition )
@@ -2572,7 +2776,7 @@
          expr1 = new E_Subtract(expr1, expr2) ;
         break;
       default:
-        jj_la1[108] = jj_gen;
+        jj_la1[116] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
@@ -2584,7 +2788,7 @@
   final public Expr MultiplicativeExpression() throws ParseException {
                                     Expr expr1, expr2 ;
     expr1 = UnaryExpression();
-    label_29:
+    label_32:
     while (true) {
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case STAR:
@@ -2592,8 +2796,8 @@
         ;
         break;
       default:
-        jj_la1[109] = jj_gen;
-        break label_29;
+        jj_la1[117] = jj_gen;
+        break label_32;
       }
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case STAR:
@@ -2607,7 +2811,7 @@
       expr1 = new E_Divide(expr1, expr2) ;
         break;
       default:
-        jj_la1[110] = jj_gen;
+        jj_la1[118] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
@@ -2672,7 +2876,7 @@
                                  {if (true) return expr ;}
       break;
     default:
-      jj_la1[111] = jj_gen;
+      jj_la1[119] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -2741,7 +2945,7 @@
                              {if (true) return expr ;}
       break;
     default:
-      jj_la1[112] = jj_gen;
+      jj_la1[120] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -2840,7 +3044,7 @@
                                {if (true) return expr ;}
       break;
     default:
-      jj_la1[113] = jj_gen;
+      jj_la1[121] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -2860,7 +3064,7 @@
       flagsExpr = Expression();
       break;
     default:
-      jj_la1[114] = jj_gen;
+      jj_la1[122] = jj_gen;
       ;
     }
     jj_consume_token(RPAREN);
@@ -2888,7 +3092,7 @@
       agg = AggregateSum();
       break;
     default:
-      jj_la1[115] = jj_gen;
+      jj_la1[123] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -2928,13 +3132,13 @@
                     agg = new AggCountVarDistinct(v) ;
         break;
       default:
-        jj_la1[116] = jj_gen;
+        jj_la1[124] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
       break;
     default:
-      jj_la1[117] = jj_gen;
+      jj_la1[125] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -2970,7 +3174,7 @@
       a = ArgList();
       break;
     default:
-      jj_la1[118] = jj_gen;
+      jj_la1[126] = jj_gen;
       ;
     }
       if ( a == null ) {if (true) return asExpr(createNode(iri)) ;}
@@ -2995,13 +3199,13 @@
         uri = IRIref();
         break;
       default:
-        jj_la1[119] = jj_gen;
+        jj_la1[127] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
       break;
     default:
-      jj_la1[120] = jj_gen;
+      jj_la1[128] = jj_gen;
       ;
     }
       {if (true) return createLiteral(lex, lang, uri) ;}
@@ -3027,7 +3231,7 @@
       n = NumericLiteralNegative();
       break;
     default:
-      jj_la1[121] = jj_gen;
+      jj_la1[129] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -3051,7 +3255,7 @@
                  {if (true) return createLiteralDouble(t.image) ;}
       break;
     default:
-      jj_la1[122] = jj_gen;
+      jj_la1[130] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -3074,7 +3278,7 @@
                           {if (true) return createLiteralDouble(t.image) ;}
       break;
     default:
-      jj_la1[123] = jj_gen;
+      jj_la1[131] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -3097,7 +3301,7 @@
                           {if (true) return createLiteralDouble(t.image) ;}
       break;
     default:
-      jj_la1[124] = jj_gen;
+      jj_la1[132] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -3115,7 +3319,7 @@
             {if (true) return XSD_FALSE ;}
       break;
     default:
-      jj_la1[125] = jj_gen;
+      jj_la1[133] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -3142,7 +3346,7 @@
                                  lex = stripQuotes3(t.image) ;
       break;
     default:
-      jj_la1[126] = jj_gen;
+      jj_la1[134] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -3164,7 +3368,7 @@
                          {if (true) return iri ;}
       break;
     default:
-      jj_la1[127] = jj_gen;
+      jj_la1[135] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -3183,7 +3387,7 @@
       {if (true) return resolvePName(t.image, t.beginLine, t.beginColumn) ;}
       break;
     default:
-      jj_la1[128] = jj_gen;
+      jj_la1[136] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -3202,7 +3406,7 @@
            {if (true) return createBNode() ;}
       break;
     default:
-      jj_la1[129] = jj_gen;
+      jj_la1[137] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -3223,379 +3427,379 @@
     finally { jj_save(0, xla); }
   }
 
-  private boolean jj_3R_67() {
-    if (jj_scan_token(STRING_LITERAL2)) return true;
-    return false;
-  }
-
-  private boolean jj_3R_66() {
-    if (jj_scan_token(STRING_LITERAL1)) return true;
+  private boolean jj_3R_40() {
+    if (jj_3R_44()) return true;
     return false;
   }
 
-  private boolean jj_3R_33() {
+  private boolean jj_3R_37() {
     Token xsp;
     xsp = jj_scanpos;
-    if (jj_3R_35()) {
+    if (jj_3R_40()) {
     jj_scanpos = xsp;
-    if (jj_3R_36()) return true;
+    if (jj_3R_41()) return true;
     }
     return false;
   }
 
+  private boolean jj_3R_53() {
+    if (jj_3R_59()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_67() {
+    if (jj_scan_token(IRIref)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_66() {
+    if (jj_scan_token(ANON)) return true;
+    return false;
+  }
+
   private boolean jj_3R_56() {
     Token xsp;
     xsp = jj_scanpos;
-    if (jj_3R_66()) {
-    jj_scanpos = xsp;
-    if (jj_3R_67()) {
-    jj_scanpos = xsp;
-    if (jj_3R_68()) {
+    if (jj_3R_65()) {
     jj_scanpos = xsp;
-    if (jj_3R_69()) return true;
-    }
-    }
+    if (jj_3R_66()) return true;
     }
     return false;
   }
 
-  private boolean jj_3R_61() {
-    if (jj_scan_token(FALSE)) return true;
+  private boolean jj_3R_65() {
+    if (jj_scan_token(BLANK_NODE_LABEL)) return true;
     return false;
   }
 
-  private boolean jj_3R_52() {
-    Token xsp;
-    xsp = jj_scanpos;
-    if (jj_3R_60()) {
-    jj_scanpos = xsp;
-    if (jj_3R_61()) return true;
-    }
+  private boolean jj_3R_51() {
+    if (jj_scan_token(NIL)) return true;
     return false;
   }
 
-  private boolean jj_3R_60() {
-    if (jj_scan_token(TRUE)) return true;
+  private boolean jj_3R_77() {
+    if (jj_scan_token(PNAME_NS)) return true;
     return false;
   }
 
-  private boolean jj_3R_83() {
-    if (jj_scan_token(DOUBLE_NEGATIVE)) return true;
+  private boolean jj_3R_50() {
+    if (jj_3R_56()) return true;
     return false;
   }
 
-  private boolean jj_3R_82() {
-    if (jj_scan_token(DECIMAL_NEGATIVE)) return true;
+  private boolean jj_3R_49() {
+    if (jj_3R_55()) return true;
     return false;
   }
 
-  private boolean jj_3R_81() {
-    if (jj_scan_token(INTEGER_NEGATIVE)) return true;
+  private boolean jj_3R_48() {
+    if (jj_3R_54()) return true;
     return false;
   }
 
-  private boolean jj_3R_72() {
-    Token xsp;
-    xsp = jj_scanpos;
-    if (jj_3R_81()) {
-    jj_scanpos = xsp;
-    if (jj_3R_82()) {
-    jj_scanpos = xsp;
-    if (jj_3R_83()) return true;
-    }
-    }
+  private boolean jj_3R_76() {
+    if (jj_scan_token(PNAME_LN)) return true;
     return false;
   }
 
-  private boolean jj_3R_80() {
-    if (jj_scan_token(DOUBLE_POSITIVE)) return true;
+  private boolean jj_3R_35() {
+    if (jj_3R_37()) return true;
     return false;
   }
 
-  private boolean jj_3R_79() {
-    if (jj_scan_token(DECIMAL_POSITIVE)) return true;
+  private boolean jj_3R_47() {
+    if (jj_3R_53()) return true;
     return false;
   }
 
-  private boolean jj_3R_78() {
-    if (jj_scan_token(INTEGER_POSITIVE)) return true;
+  private boolean jj_3R_46() {
+    if (jj_3R_52()) return true;
     return false;
   }
 
-  private boolean jj_3R_71() {
+  private boolean jj_3R_43() {
     Token xsp;
     xsp = jj_scanpos;
-    if (jj_3R_78()) {
+    if (jj_3R_46()) {
     jj_scanpos = xsp;
-    if (jj_3R_79()) {
+    if (jj_3R_47()) {
     jj_scanpos = xsp;
-    if (jj_3R_80()) return true;
+    if (jj_3R_48()) {
+    jj_scanpos = xsp;
+    if (jj_3R_49()) {
+    jj_scanpos = xsp;
+    if (jj_3R_50()) {
+    jj_scanpos = xsp;
+    if (jj_3R_51()) return true;
+    }
+    }
+    }
     }
     }
     return false;
   }
 
-  private boolean jj_3R_77() {
-    if (jj_scan_token(DOUBLE)) return true;
+  private boolean jj_3R_68() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_76()) {
+    jj_scanpos = xsp;
+    if (jj_3R_77()) return true;
+    }
     return false;
   }
 
-  private boolean jj_3R_76() {
-    if (jj_scan_token(DECIMAL)) return true;
+  private boolean jj_3R_33() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_34()) {
+    jj_scanpos = xsp;
+    if (jj_3R_35()) return true;
+    }
     return false;
   }
 
-  private boolean jj_3R_75() {
-    if (jj_scan_token(INTEGER)) return true;
+  private boolean jj_3R_34() {
+    if (jj_3R_36()) return true;
     return false;
   }
 
-  private boolean jj_3R_70() {
+  private boolean jj_3R_42() {
     Token xsp;
     xsp = jj_scanpos;
-    if (jj_3R_75()) {
-    jj_scanpos = xsp;
-    if (jj_3R_76()) {
+    if (jj_scan_token(12)) {
     jj_scanpos = xsp;
-    if (jj_3R_77()) return true;
-    }
+    if (jj_scan_token(13)) return true;
     }
     return false;
   }
 
-  private boolean jj_3R_41() {
-    if (jj_scan_token(LPAREN)) return true;
-    return false;
-  }
-
-  private boolean jj_3R_59() {
-    if (jj_3R_72()) return true;
+  private boolean jj_3R_39() {
+    if (jj_3R_43()) return true;
     return false;
   }
 
   private boolean jj_3R_58() {
-    if (jj_3R_71()) return true;
+    if (jj_3R_68()) return true;
     return false;
   }
 
-  private boolean jj_3R_57() {
-    if (jj_3R_70()) return true;
-    return false;
-  }
-
-  private boolean jj_3R_51() {
+  private boolean jj_3R_52() {
     Token xsp;
     xsp = jj_scanpos;
     if (jj_3R_57()) {
     jj_scanpos = xsp;
-    if (jj_3R_58()) {
-    jj_scanpos = xsp;
-    if (jj_3R_59()) return true;
-    }
+    if (jj_3R_58()) return true;
     }
     return false;
   }
 
-  private boolean jj_3R_42() {
-    if (jj_scan_token(LBRACKET)) return true;
+  private boolean jj_3R_57() {
+    if (jj_3R_67()) return true;
     return false;
   }
 
-  private boolean jj_3R_38() {
-    if (jj_3R_42()) return true;
+  private boolean jj_3_1() {
+    if (jj_scan_token(DOT)) return true;
+    if (jj_3R_33()) return true;
     return false;
   }
 
-  private boolean jj_3R_37() {
-    if (jj_3R_41()) return true;
+  private boolean jj_3R_72() {
+    if (jj_scan_token(STRING_LITERAL_LONG2)) return true;
     return false;
   }
 
-  private boolean jj_3R_34() {
-    Token xsp;
-    xsp = jj_scanpos;
-    if (jj_3R_37()) {
-    jj_scanpos = xsp;
-    if (jj_3R_38()) return true;
-    }
+  private boolean jj_3R_71() {
+    if (jj_scan_token(STRING_LITERAL_LONG1)) return true;
     return false;
   }
 
-  private boolean jj_3R_50() {
-    if (jj_3R_56()) return true;
+  private boolean jj_3R_38() {
+    if (jj_3R_42()) return true;
     return false;
   }
 
-  private boolean jj_3R_64() {
-    if (jj_scan_token(IRIref)) return true;
+  private boolean jj_3R_70() {
+    if (jj_scan_token(STRING_LITERAL2)) return true;
     return false;
   }
 
-  private boolean jj_3R_63() {
-    if (jj_scan_token(ANON)) return true;
+  private boolean jj_3R_69() {
+    if (jj_scan_token(STRING_LITERAL1)) return true;
     return false;
   }
 
-  private boolean jj_3R_53() {
+  private boolean jj_3R_36() {
     Token xsp;
     xsp = jj_scanpos;
-    if (jj_3R_62()) {
+    if (jj_3R_38()) {
     jj_scanpos = xsp;
-    if (jj_3R_63()) return true;
+    if (jj_3R_39()) return true;
     }
     return false;
   }
 
-  private boolean jj_3R_62() {
-    if (jj_scan_token(BLANK_NODE_LABEL)) return true;
+  private boolean jj_3R_59() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_69()) {
+    jj_scanpos = xsp;
+    if (jj_3R_70()) {
+    jj_scanpos = xsp;
+    if (jj_3R_71()) {
+    jj_scanpos = xsp;
+    if (jj_3R_72()) return true;
+    }
+    }
+    }
     return false;
   }
 
-  private boolean jj_3R_48() {
-    if (jj_scan_token(NIL)) return true;
+  private boolean jj_3R_64() {
+    if (jj_scan_token(FALSE)) return true;
     return false;
   }
 
-  private boolean jj_3R_74() {
-    if (jj_scan_token(PNAME_NS)) return true;
+  private boolean jj_3R_55() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_63()) {
+    jj_scanpos = xsp;
+    if (jj_3R_64()) return true;
+    }
     return false;
   }
 
-  private boolean jj_3R_47() {
-    if (jj_3R_53()) return true;
+  private boolean jj_3R_63() {
+    if (jj_scan_token(TRUE)) return true;
     return false;
   }
 
-  private boolean jj_3R_46() {
-    if (jj_3R_52()) return true;
+  private boolean jj_3R_86() {
+    if (jj_scan_token(DOUBLE_NEGATIVE)) return true;
     return false;
   }
 
-  private boolean jj_3R_45() {
-    if (jj_3R_51()) return true;
+  private boolean jj_3R_85() {
+    if (jj_scan_token(DECIMAL_NEGATIVE)) return true;
     return false;
   }
 
-  private boolean jj_3R_73() {
-    if (jj_scan_token(PNAME_LN)) return true;
+  private boolean jj_3R_84() {
+    if (jj_scan_token(INTEGER_NEGATIVE)) return true;
     return false;
   }
 
-  private boolean jj_3R_32() {
-    if (jj_3R_34()) return true;
+  private boolean jj_3R_75() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_84()) {
+    jj_scanpos = xsp;
+    if (jj_3R_85()) {
+    jj_scanpos = xsp;
+    if (jj_3R_86()) return true;
+    }
+    }
     return false;
   }
 
-  private boolean jj_3R_44() {
-    if (jj_3R_50()) return true;
+  private boolean jj_3R_83() {
+    if (jj_scan_token(DOUBLE_POSITIVE)) return true;
     return false;
   }
 
-  private boolean jj_3R_43() {
-    if (jj_3R_49()) return true;
+  private boolean jj_3R_82() {
+    if (jj_scan_token(DECIMAL_POSITIVE)) return true;
     return false;
   }
 
-  private boolean jj_3R_40() {
+  private boolean jj_3R_81() {
+    if (jj_scan_token(INTEGER_POSITIVE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_74() {
     Token xsp;
     xsp = jj_scanpos;
-    if (jj_3R_43()) {
-    jj_scanpos = xsp;
-    if (jj_3R_44()) {
-    jj_scanpos = xsp;
-    if (jj_3R_45()) {
-    jj_scanpos = xsp;
-    if (jj_3R_46()) {
+    if (jj_3R_81()) {
     jj_scanpos = xsp;
-    if (jj_3R_47()) {
+    if (jj_3R_82()) {
     jj_scanpos = xsp;
-    if (jj_3R_48()) return true;
-    }
-    }
-    }
+    if (jj_3R_83()) return true;
     }
     }
     return false;
   }
 
-  private boolean jj_3R_65() {
-    Token xsp;
-    xsp = jj_scanpos;
-    if (jj_3R_73()) {
-    jj_scanpos = xsp;
-    if (jj_3R_74()) return true;
-    }
+  private boolean jj_3R_80() {
+    if (jj_scan_token(DOUBLE)) return true;
     return false;
   }
 
-  private boolean jj_3R_30() {
-    Token xsp;
-    xsp = jj_scanpos;
-    if (jj_3R_31()) {
-    jj_scanpos = xsp;
-    if (jj_3R_32()) return true;
-    }
+  private boolean jj_3R_79() {
+    if (jj_scan_token(DECIMAL)) return true;
     return false;
   }
 
-  private boolean jj_3R_31() {
-    if (jj_3R_33()) return true;
+  private boolean jj_3R_78() {
+    if (jj_scan_token(INTEGER)) return true;
     return false;
   }
 
-  private boolean jj_3R_39() {
+  private boolean jj_3R_73() {
     Token xsp;
     xsp = jj_scanpos;
-    if (jj_scan_token(12)) {
+    if (jj_3R_78()) {
     jj_scanpos = xsp;
-    if (jj_scan_token(13)) return true;
+    if (jj_3R_79()) {
+    jj_scanpos = xsp;
+    if (jj_3R_80()) return true;
     }
-    return false;
-  }
-
-  private boolean jj_3R_36() {
-    if (jj_3R_40()) return true;
+    }
     return false;
   }
 
-  private boolean jj_3R_55() {
-    if (jj_3R_65()) return true;
+  private boolean jj_3R_44() {
+    if (jj_scan_token(LPAREN)) return true;
     return false;
   }
 
-  private boolean jj_3R_49() {
-    Token xsp;
-    xsp = jj_scanpos;
-    if (jj_3R_54()) {
-    jj_scanpos = xsp;
-    if (jj_3R_55()) return true;
-    }
+  private boolean jj_3R_62() {
+    if (jj_3R_75()) return true;
     return false;
   }
 
-  private boolean jj_3R_54() {
-    if (jj_3R_64()) return true;
+  private boolean jj_3R_61() {
+    if (jj_3R_74()) return true;
     return false;
   }
 
-  private boolean jj_3_1() {
-    if (jj_scan_token(DOT)) return true;
-    if (jj_3R_30()) return true;
+  private boolean jj_3R_60() {
+    if (jj_3R_73()) return true;
     return false;
   }
 
-  private boolean jj_3R_69() {
-    if (jj_scan_token(STRING_LITERAL_LONG2)) return true;
+  private boolean jj_3R_54() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_60()) {
+    jj_scanpos = xsp;
+    if (jj_3R_61()) {
+    jj_scanpos = xsp;
+    if (jj_3R_62()) return true;
+    }
+    }
     return false;
   }
 
-  private boolean jj_3R_68() {
-    if (jj_scan_token(STRING_LITERAL_LONG1)) return true;
+  private boolean jj_3R_45() {
+    if (jj_scan_token(LBRACKET)) return true;
     return false;
   }
 
-  private boolean jj_3R_35() {
-    if (jj_3R_39()) return true;
+  private boolean jj_3R_41() {
+    if (jj_3R_45()) return true;
     return false;
   }
 
@@ -3610,7 +3814,7 @@
   private Token jj_scanpos, jj_lastpos;
   private int jj_la;
   private int jj_gen;
-  final private int[] jj_la1 = new int[130];
+  final private int[] jj_la1 = new int[138];
   static private int[] jj_la1_0;
   static private int[] jj_la1_1;
   static private int[] jj_la1_2;
@@ -3624,19 +3828,19 @@
       jj_la1_init_4();
    }
    private static void jj_la1_init_0() {
-      jj_la1_0 = new int[] {0x3900000,0x40000,0x80000,0x600000,0x600000,0x0,0x3700,0x3700,0x3700,0x0,0x0,0x3700,0x3700,0x0,0x0,0x0,0x700,0x0,0x0,0x0,0x10000000,0xc000000,0x3700,0x0,0x3700,0x700,0xc0003700,0xc0000000,0x3700,0xc0003700,0x8000000,0x4000000,0xc000000,0x0,0x0,0x0,0x0,0x0,0x700,0x700,0x0,0x700,0x0,0x0,0x700,0x700,0x0,0x700,0x0,0x0,0x700,0x0,0x0,0x0,0x0,0x0,0x0,0x1c0000,0x3f00,0x0,0x0,0x0,0x3f00,0x3f00,0x0,0x0,0x0,0x700,0x0,0x0,0x3f00,0x0,0x3f00,0x0,0x23700,0x23700,0x0,0x23700,0x3f00,0x23700,0x0,0x23700,0x23700,0x23700,0x0,0x0,0x0,0x20700,0x0,0x0,0x0,0x0,0x20700,0x0,0x3f00,0x3f00,0x3f00,0x3700,0x3000,0xf00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3700,0x3700,0x0,0x0,0x0,0x3000,0x203000,0x0,0x4000,0x4000,0x0,0x0,0x0,0x0,0x0,0x0,0x700,0x600,0x800,};
+      jj_la1_0 = new int[] {0x100000,0x7200000,0x40000,0x80000,0xc00000,0xc00000,0x0,0x3700,0x3700,0x3700,0x0,0x0,0x3000,0x3f00,0x3f00,0x3f00,0x0,0x8000000,0x3700,0x3700,0x0,0x0,0x18003700,0x0,0x700,0x0,0x0,0x0,0x80000000,0x60000000,0x3700,0x0,0x3700,0x700,0x3700,0x0,0x3700,0x3700,0x40000000,0x20000000,0x60000000,0x0,0x0,0x0,0x0,0x0,0x700,0x700,0x0,0x700,0x0,0x0,0x700,0x700,0x0,0x700,0x0,0x0,0x700,0x0,0x0,0x0,0x0,0x0,0x0,0x2c0000,0x3f00,0x0,0x0,0x0,0x3f00,0x3f00,0x0,0x0,0x0,0x700,0x0,0x0,0x3f00,0x0,0x3f00,0x0,0x23700,0x23700,0x0,0x23700,0x3f00,0x23700,0x0,0x23700,0x23700,0x23700,0x0,0x0,0x0,0x20700,0x0,0x0,0x0,0x0,0x20700,0x0,0x3f00,0x3f00,0x3f00,0x3700,0x3000,0xf00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3700,0x3700,0x0,0x0,0x0,0x3000,0x403000,0x0,0x4000,0x4000,0x0,0x0,0x0,0x0,0x0,0x0,0x700,0x600,0x800,};
    }
    private static void jj_la1_init_1() {
-      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x200,0xffc24000,0xffc24000,0xffc24000,0x2,0x2,0x0,0x0,0x2,0x4,0x2,0x1,0x4,0x800,0x1000,0x0,0x0,0xffc00000,0x200,0xffc00000,0xffc00000,0xffc00000,0x0,0xffc00000,0xffc00000,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x4,0x2,0x2,0x2,0x2,0x2,0x4,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x10,0x0,0x0,0x0,0x4,0x0,0x0,0x3004b0,0x3004b0,0x0,0x0,0x0,0x0,0x1004b0,0x40,0xffc00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffc24000,0xffc24000,0xffc00000,0x0,0x24000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
+      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x2000,0xfc240000,0xfc240000,0xfc240000,0x20,0x2,0x0,0x0,0x0,0x0,0x20,0x800,0x0,0x0,0x20,0x40,0x800,0x20,0x10,0x40,0x8000,0x10000,0x0,0x0,0xfc000000,0x2000,0xfc000000,0xfc000000,0xfc00000c,0xc,0xfc000000,0xfc00000c,0x0,0x0,0x0,0x0,0x0,0x0,0x100,0x40,0x20,0x20,0x20,0x20,0x20,0x40,0x0,0x0,0x0,0x0,0x0,0x40,0x0,0x0,0x100,0x0,0x0,0x0,0x40,0x0,0x0,0x3004b00,0x3004b00,0x0,0x0,0x0,0x0,0x1004b00,0x400,0xfc000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfc240000,0xfc240000,0xfc000000,0x0,0x240000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
    }
    private static void jj_la1_init_2() {
-      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x1,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x1,0x1,0x1,0x0,0x1,0x1,0x0,0x0,0x0,0x2e38,0x2e38,0x638,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x4040,0x4000,0x4000,0x4000,0x4000,0x0,0x0,0x4000,0x0,0x2800,0x1000,0x1000,0x0,0x0,0xe1ff0006,0x0,0x0,0x0,0xe1ff0006,0xe1ff0006,0x0,0x0,0x0,0x1,0x0,0x0,0xe1ff0006,0x0,0xe1ff0006,0x0,0x0,0x0,0x0,0x0,0xe1ff0006,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000,0x0,0x0,0x0,0x0,0xe1ff0006,0xe1ff0006,0xe1ff0006,0x0,0x0,0xe1ff0006,0x0,0x0,0x0,0x0,0x1f80000,0x1f80000,0x0,0x0,0x1f80000,0x0,0x0,0xe1ff0007,0xe1ff0007,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1ff0000,0x70000,0x380000,0x1c00000,0x6,0xe0000000,0x0,0x0,0x0,};
+      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1f,0x1f,0x1f,0x0,0x0,0x0,0x1ff00060,0x1ff00060,0x1ff00060,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1f,0x0,0x1f,0x1f,0x1f,0x0,0x1f,0x1f,0x0,0x0,0x0,0x2e380,0x2e380,0x6380,0x0,0x0,0x400,0x0,0x0,0x0,0x0,0x0,0x40400,0x40000,0x40000,0x40000,0x40000,0x0,0x0,0x40000,0x0,0x28000,0x10000,0x10000,0x0,0x0,0x1ff00060,0x0,0x0,0x0,0x1ff00060,0x1ff00060,0x0,0x0,0x0,0x1f,0x0,0x0,0x1ff00060,0x0,0x1ff00060,0x0,0x0,0x0,0x0,0x0,0x1ff00060,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100000,0x0,0x0,0x0,0x0,0x1ff00060,0x1ff00060,0x1ff00060,0x0,0x0,0x1ff00060,0x0,0x0,0x0,0x0,0x1f800000,0x1f800000,0x0,0x0,0x1f800000,0x0,0x0,0x1ff0007f,0x1ff0007f,0x1f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1ff00000,0x700000,0x3800000,0x1c000000,0x60,0x0,0x0,0x0,0x0,};
    }
    private static void jj_la1_init_3() {
-      jj_la1_3 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x2,0x2000002,0x0,0x0,0x0,0x2000000,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x2,0x2,0x2,0x0,0x2,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x10,0x0,0x0,0x0,0x0,0x10,0x10,0x0,0x0,0x0,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x14b,0x10,0x10,0x800,0x14b,0x14b,0x800,0x10,0x0,0x2,0x400,0xa,0x14b,0x800,0x14b,0x200,0x0,0x0,0x400,0x0,0x14b,0x80000002,0x200,0x80000002,0x80000002,0x0,0x40000000,0x84000000,0x84000000,0x80000002,0x2800010,0x20,0x420,0x2800010,0x2,0x42,0x14b,0x14b,0x109,0x0,0x0,0x109,0x200000,0x400000,0x3f000,0x3f000,0x1800000,0x0,0x6000000,0x6000000,0x1800000,0x6000000,0x6000000,0x1840003,0x3,0x0,0x400,0x0,0x2000000,0x2000000,0xa,0x8000000,0x8000000,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x100,};
+      jj_la1_3 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x20,0x20000020,0x0,0x0,0x0,0x909e,0x109e,0x109e,0x0,0x0,0x0,0x20000000,0x0,0x100,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x0,0x20,0x20,0x20,0x0,0x20,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100,0x100,0x0,0x0,0x0,0x0,0x100,0x100,0x0,0x0,0x0,0x0,0x100,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x14be,0x100,0x100,0x8000,0x14be,0x14be,0x8000,0x100,0x0,0x20,0x4000,0xa0,0x14be,0x8000,0x14be,0x2000,0x0,0x0,0x4000,0x0,0x14be,0x20,0x2000,0x20,0x20,0x0,0x0,0x40000000,0x40000000,0x20,0x28000100,0x200,0x4200,0x28000100,0x20,0x420,0x14be,0x14be,0x109e,0x0,0x0,0x109e,0x2000000,0x4000000,0x3f0000,0x3f0000,0x18000000,0x0,0x60000000,0x60000000,0x18000000,0x60000000,0x60000000,0x1840003e,0x3e,0x0,0x4000,0x0,0x20000000,0x20000000,0xa0,0x80000000,0x80000000,0x0,0x0,0x0,0x0,0x0,0x1e,0x0,0x0,0x1000,};
    }
    private static void jj_la1_init_4() {
-      jj_la1_4 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
+      jj_la1_4 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x80,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x8,0x8,0x0,0x4,0x8,0x8,0x8,0x40,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
    }
   final private JJCalls[] jj_2_rtns = new JJCalls[1];
   private boolean jj_rescan = false;
@@ -3653,7 +3857,7 @@
     token = new Token();
     jj_ntk = -1;
     jj_gen = 0;
-    for (int i = 0; i < 130; i++) jj_la1[i] = -1;
+    for (int i = 0; i < 138; i++) jj_la1[i] = -1;
     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
   }
 
@@ -3668,7 +3872,7 @@
     token = new Token();
     jj_ntk = -1;
     jj_gen = 0;
-    for (int i = 0; i < 130; i++) jj_la1[i] = -1;
+    for (int i = 0; i < 138; i++) jj_la1[i] = -1;
     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
   }
 
@@ -3679,7 +3883,7 @@
     token = new Token();
     jj_ntk = -1;
     jj_gen = 0;
-    for (int i = 0; i < 130; i++) jj_la1[i] = -1;
+    for (int i = 0; i < 138; i++) jj_la1[i] = -1;
     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
   }
 
@@ -3690,7 +3894,7 @@
     token = new Token();
     jj_ntk = -1;
     jj_gen = 0;
-    for (int i = 0; i < 130; i++) jj_la1[i] = -1;
+    for (int i = 0; i < 138; i++) jj_la1[i] = -1;
     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
   }
 
@@ -3700,7 +3904,7 @@
     token = new Token();
     jj_ntk = -1;
     jj_gen = 0;
-    for (int i = 0; i < 130; i++) jj_la1[i] = -1;
+    for (int i = 0; i < 138; i++) jj_la1[i] = -1;
     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
   }
 
@@ -3710,7 +3914,7 @@
     token = new Token();
     jj_ntk = -1;
     jj_gen = 0;
-    for (int i = 0; i < 130; i++) jj_la1[i] = -1;
+    for (int i = 0; i < 138; i++) jj_la1[i] = -1;
     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
   }
 
@@ -3788,7 +3992,7 @@
       return (jj_ntk = jj_nt.kind);
   }
 
-  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
+  private java.util.List jj_expentries = new java.util.ArrayList();
   private int[] jj_expentry;
   private int jj_kind = -1;
   private int[] jj_lasttokens = new int[100];
@@ -3803,8 +4007,8 @@
       for (int i = 0; i < jj_endpos; i++) {
         jj_expentry[i] = jj_lasttokens[i];
       }
-      jj_entries_loop: for (java.util.Iterator<int[]> it = jj_expentries.iterator(); it.hasNext();) {
-        int[] oldentry = (it.next());
+      jj_entries_loop: for (java.util.Iterator it = jj_expentries.iterator(); it.hasNext();) {
+        int[] oldentry = (int[])(it.next());
         if (oldentry.length == jj_expentry.length) {
           for (int i = 0; i < jj_expentry.length; i++) {
             if (oldentry[i] != jj_expentry[i]) {
@@ -3822,12 +4026,12 @@
   /** Generate ParseException. */
   public ParseException generateParseException() {
     jj_expentries.clear();
-    boolean[] la1tokens = new boolean[138];
+    boolean[] la1tokens = new boolean[143];
     if (jj_kind >= 0) {
       la1tokens[jj_kind] = true;
       jj_kind = -1;
     }
-    for (int i = 0; i < 130; i++) {
+    for (int i = 0; i < 138; i++) {
       if (jj_la1[i] == jj_gen) {
         for (int j = 0; j < 32; j++) {
           if ((jj_la1_0[i] & (1<<j)) != 0) {
@@ -3848,7 +4052,7 @@
         }
       }
     }
-    for (int i = 0; i < 138; i++) {
+    for (int i = 0; i < 143; i++) {
       if (la1tokens[i]) {
         jj_expentry = new int[1];
         jj_expentry[0] = i;
@@ -3860,7 +4064,7 @@
     jj_add_error_token(0, 0);
     int[][] exptokseq = new int[jj_expentries.size()][];
     for (int i = 0; i < jj_expentries.size(); i++) {
-      exptokseq[i] = jj_expentries.get(i);
+      exptokseq[i] = (int[])jj_expentries.get(i);
     }
     return new ParseException(token, exptokseq, tokenImage);
   }
Index: src/com/hp/hpl/jena/sparql/engine/main/OpExecutor.java
===================================================================
--- src/com/hp/hpl/jena/sparql/engine/main/OpExecutor.java	(revision 6629)
+++ src/com/hp/hpl/jena/sparql/engine/main/OpExecutor.java	(working copy)
@@ -163,12 +163,12 @@
             
             QueryIterator left = executeOp(opJoin.getLeft(), qIter1) ;
             QueryIterator right = executeOp(opJoin.getRight(), qIter2) ;
-            QueryIterator qIter = new QueryIterJoin(left, right, execCxt) ;
+            QueryIterator qIter = new QueryIterJoin(left, right, opJoin.getExprs(), execCxt) ;
             return qIter ;
         }
         QueryIterator left = executeOp(opJoin.getLeft(), input) ;
         QueryIterator right = executeOp(opJoin.getRight(), root()) ;
-        QueryIterator qIter = new QueryIterJoin(left, right, execCxt) ;
+        QueryIterator qIter = new QueryIterJoin(left, right, opJoin.getExprs(), execCxt) ;
         return qIter ;
     }
 
@@ -285,10 +285,11 @@
             input.close() ;
             return opTable.getTable().iterator(execCxt) ;
         }
+
         //throw new ARQNotImplemented("Not identity table") ;
         QueryIterator qIterT = opTable.getTable().iterator(execCxt) ;
         //QueryIterator qIterT = root() ;
-        QueryIterator qIter = new QueryIterJoin(input, qIterT, execCxt) ;
+        QueryIterator qIter = new QueryIterJoin(input, qIterT, null, execCxt) ;
         return qIter ;
     }
 
Index: src/com/hp/hpl/jena/sparql/resultset/TextOutput.java
===================================================================
--- src/com/hp/hpl/jena/sparql/resultset/TextOutput.java	(revision 6629)
+++ src/com/hp/hpl/jena/sparql/resultset/TextOutput.java	(working copy)
@@ -9,6 +9,7 @@
 import java.io.* ;
 
 import com.hp.hpl.jena.util.* ;
+import com.hp.hpl.jena.graph.TrackedNode;
 import com.hp.hpl.jena.query.QuerySolution;
 import com.hp.hpl.jena.query.ResultSet;
 import com.hp.hpl.jena.rdf.model.* ;
@@ -206,7 +207,10 @@
         if ( obj == null )
             return notThere ;
 
-        return FmtUtils.stringForRDFNode(obj, context) ;
+        String s = FmtUtils.stringForRDFNode(obj, context);
+        if (obj.asNode() instanceof TrackedNode)
+        	return s + " (source: " + FmtUtils.stringForNode(TrackedNode.getProvenanceUri(obj.asNode()), context) + ")";
+        return s;
     }
 
     public void format(OutputStream out, boolean answer)
Index: src/com/hp/hpl/jena/sparql/algebra/opt/FilterPushdown.java
===================================================================
--- src/com/hp/hpl/jena/sparql/algebra/opt/FilterPushdown.java	(revision 0)
+++ src/com/hp/hpl/jena/sparql/algebra/opt/FilterPushdown.java	(revision 0)
@@ -0,0 +1,437 @@
+package com.hp.hpl.jena.sparql.algebra.opt;
+
+import java.util.ArrayList;
+import java.util.IdentityHashMap;
+import java.util.List;
+import java.util.Set;
+
+import com.hp.hpl.jena.sparql.algebra.Op;
+import com.hp.hpl.jena.sparql.algebra.OpVars;
+import com.hp.hpl.jena.sparql.algebra.OpVisitorByType;
+import com.hp.hpl.jena.sparql.algebra.Transform;
+import com.hp.hpl.jena.sparql.algebra.TransformBase;
+import com.hp.hpl.jena.sparql.algebra.op.Op0;
+import com.hp.hpl.jena.sparql.algebra.op.Op1;
+import com.hp.hpl.jena.sparql.algebra.op.Op2;
+import com.hp.hpl.jena.sparql.algebra.op.OpExt;
+import com.hp.hpl.jena.sparql.algebra.op.OpFilter;
+import com.hp.hpl.jena.sparql.algebra.op.OpJoin;
+import com.hp.hpl.jena.sparql.algebra.op.OpLabel;
+import com.hp.hpl.jena.sparql.algebra.op.OpLeftJoin;
+import com.hp.hpl.jena.sparql.algebra.op.OpN;
+import com.hp.hpl.jena.sparql.algebra.op.OpUnion;
+import com.hp.hpl.jena.sparql.core.Var;
+import com.hp.hpl.jena.sparql.expr.E_Exists;
+import com.hp.hpl.jena.sparql.expr.Expr;
+import com.hp.hpl.jena.sparql.expr.ExprList;
+
+/**
+ * @author Andreas Langegger <dorgon@users.sf.net>
+ *
+ * a visitor-based walker which applies top-down transformations
+ * keeps child-2-parent relationships in a flat identity hash table
+ * 
+ * using the Transform interface but ignoring the supplied sub ops since
+ * this is top-down, dynamically iterating using another dispatcher visitor
+ */
+public class FilterPushdown extends TransformBase {
+	private ApplyFilterPushDown apply = new ApplyFilterPushDown(this);
+	
+	/** 
+	 * keeps parent relationships above currently processed op in a flat lookup table
+	 * subsequently build using a dispatch visitor
+	 * 
+	 * Any changes (e.g. insert) to a sub tree below the currently transformed op don't need special care regarding the child2parent lookup table.
+	 * Also okay: remove single op above: just a call to switchChild(op, op.getSubOp()) -> references are updated
+	 */
+	protected final IdentityHashMap<Op, Op> child2parent = new IdentityHashMap<Op, Op>();
+
+	/**
+	 * applies the filter push down
+	 *
+	 * @param op
+	 * @return transformed op
+	 */
+	public static Op apply(Op op) {
+		return new FilterPushdown().applyTransformations(op);
+	}
+
+	/** private apply */
+	private Op applyTransformations(Op op) {
+		// insert root dummy
+		OpLabel root = (OpLabel) OpLabel.create("root dummy", op);
+		root.visit(apply);
+		return root.getSubOp();	
+	}
+	
+// specific transform implementations
+	
+	/**
+	 * merge subsequent filters
+	 */
+	@Override
+	public Op transform(OpFilter opFilter, Op ignore) {
+		// merge filter with sub filter if any
+		if (opFilter.getSubOp() instanceof OpFilter) {
+			OpFilter subFilter = (OpFilter) opFilter.getSubOp();
+			opFilter.getExprs().addAll(subFilter.getExprs());
+			switchChild(subFilter, subFilter.getSubOp());
+		}
+		
+		// replace falsum with OpNull?
+		// e.g. ?x = 6 or ?x = ?y is always false if ?x out of variable scope
+		
+		return opFilter;
+	}
+	
+	/**
+	 * using join behavior now
+	 * 
+	 * TODO check with AndyS:
+	 * But normally, can't we copy down expressions both sides?
+	 * 
+	 * select * where {
+	 *   { ?s a foaf:Person ; foaf:name ?name }
+	 *   UNION
+	 *   { ?s a bsbm:Product ; rdfs:label ?name2 }
+	 *   FILTER (?name = ?name2)
+	 * }
+	 * => no results, but
+	 * select * where {
+	 *   { ?s a foaf:Person ; foaf:name ?name . FILTER (?name = ?name2) }
+	 *   UNION
+	 *   { ?s a bsbm:Product ; rdfs:label ?name2 . FILTER (?name = ?name2) }
+	 * }
+	 * => gives results and ignores unsatisfiable expression (?name = ?name2)
+	 * 
+	 * 
+	 * given expressions:
+	 *   e_1, e_2, ... where E = e_1 && e_2 && ... e_i && ... e_n
+	 * given variable sets:
+	 *   V_l (left scope)
+	 *   V_r (right scope)
+	 *   V_e (variables in e_i)
+	 * 
+	 * push down e_i left/right if:
+	 *   V_e subsetOf V_l / V_r
+	 * keep e_i in place if:
+	 *   V_e !subsetOf V_l && V_e !subsetOf V_r
+	 */
+	@Override
+	public Op transform(OpUnion opUnion, Op ignore1, Op ignore2) {
+		OpFilter filter = getFilterParent(opUnion);
+		if (filter != null) {
+			ExprList leftExprs = new ExprList();
+			ExprList rightExprs = new ExprList();
+			ExprList keptExprs = new ExprList();
+			
+			Set<Var> V_e, V_l, V_r;
+			boolean leftSubset;
+			boolean rightSubset;
+			
+			// for each filter expression
+			for (Expr e : filter.getExprs()) {
+
+				// check if all vars exclusively in left scope
+				V_e = e.getVarsMentioned();
+				V_l = OpVars.allVars(opUnion.getLeft());
+				V_e.removeAll(V_l);
+				leftSubset = V_e.size() == 0;
+
+				V_e = e.getVarsMentioned();
+				V_r = OpVars.allVars(opUnion.getRight());
+				V_e.removeAll(V_r);
+				rightSubset = V_e.size() == 0;
+				
+				if (leftSubset && canPushDown(e))
+					leftExprs.add(e);
+				if (rightSubset && canPushDown(e))
+					rightExprs.add(e);
+				if (!leftSubset && !rightSubset)
+					keptExprs.add(e);
+			}
+			
+			// insert filters below union
+			if (leftExprs.size() > 0)
+				opUnion.setLeft(OpFilter.filter(leftExprs, opUnion.getLeft()));
+			if (rightExprs.size() > 0)
+				opUnion.setRight(OpFilter.filter(rightExprs, opUnion.getRight()));
+			
+			// if keep is empty remove previous filter
+			if (keptExprs.size() == 0) {
+				switchChild(filter, opUnion);
+			} else {
+				Op newFilter = OpFilter.filter(keptExprs, opUnion);
+				switchChild(filter, newFilter);
+			}
+		}
+		return opUnion;
+	}
+
+	/**
+	 * given expressions:
+	 *   e_1, e_2, ... where E = e_1 && e_2 && ... e_i && ... e_n
+	 * given variable sets:
+	 *   V_l (left scope)
+	 *   V_r (right scope)
+	 *   V_e (variables in e_i)
+	 * 
+	 * push down e_i left/right if:
+	 *   V_e subsetOf V_l / V_r
+	 * keep e_i in place if:
+	 *   V_e !subsetOf V_l && V_e !subsetOf V_r
+	 */
+	@Override
+	public Op transform(OpJoin opJoin, Op ignore1, Op ignore2) {
+		OpFilter filter = getFilterParent(opJoin);
+		if (filter != null) {
+			ExprList leftExprs = new ExprList();
+			ExprList rightExprs = new ExprList();
+			ExprList keptExprs = new ExprList();					
+
+			Set<Var> V_e, V_l, V_r;
+			boolean leftSubset;
+			boolean rightSubset;
+			
+			// for each filter expression
+			for (Expr e : filter.getExprs()) {
+
+				// check if all vars exclusively in left scope
+				V_e = e.getVarsMentioned();
+				V_l = OpVars.allVars(opJoin.getLeft());
+				V_e.removeAll(V_l);
+				leftSubset = V_e.size() == 0;
+
+				V_e = e.getVarsMentioned();
+				V_r = OpVars.allVars(opJoin.getRight());
+				V_e.removeAll(V_r);
+				rightSubset = V_e.size() == 0;
+				
+				if (leftSubset && canPushDown(e))
+					leftExprs.add(e);
+				if (rightSubset && canPushDown(e))
+					rightExprs.add(e);
+				if (!leftSubset && !rightSubset)
+					keptExprs.add(e);
+			}
+			
+			// insert filters below join
+			if (leftExprs.size() > 0)
+				opJoin.setLeft(OpFilter.filter(leftExprs, opJoin.getLeft()));
+			if (rightExprs.size() > 0)
+				opJoin.setRight(OpFilter.filter(rightExprs, opJoin.getRight()));
+			
+			// if keep is empty remove previous filter
+			if (keptExprs.size() == 0) {
+				switchChild(filter, opJoin);
+			} else {
+				Op newFilter = OpFilter.filter(keptExprs, opJoin);
+				switchChild(filter, newFilter);
+			}
+		}
+		return opJoin;
+	}
+	
+	/**
+	 * given expressions:
+	 *   e_1, e_2, ... where E = e_1 && e_2 && ... e_i && ... e_n
+	 * given variable sets:
+	 *   V_l (left scope)
+	 *   V_r (right scope)
+	 *   V_e (variables in e_i)
+	 * 
+	 * push down e_i left if:
+	 *   V_e subsetOf V_l
+	 * keep e_i in place if:
+	 *   V_e !subsetOf V_l && V_e !subsetOf V_r
+	 * 
+	 * Don't push down right -> ARQ will probably take it as a conditional left join
+	 */
+	@Override
+	public Op transform(OpLeftJoin opLeftJoin, Op left, Op right) {
+		OpFilter filter = getFilterParent(opLeftJoin);
+		if (filter != null) {
+			ExprList leftExprs = new ExprList();
+			ExprList keptExprs = new ExprList();
+
+			Set<Var> V_e, V_l, V_r;
+			boolean leftSubset;
+			
+			// for each filter expression
+			for (Expr e : filter.getExprs()) {
+
+				// check if all vars exclusively in left scope
+				V_e = e.getVarsMentioned();
+				V_l = OpVars.allVars(opLeftJoin.getLeft());
+				V_e.removeAll(V_l);
+				leftSubset = V_e.size() == 0;
+				
+				if (leftSubset && canPushDown(e))
+					leftExprs.add(e);
+				else
+					keptExprs.add(e);
+			}
+			
+			// insert filters below left join
+			if (leftExprs.size() > 0)
+				opLeftJoin.setLeft(OpFilter.filter(leftExprs, opLeftJoin.getLeft()));
+			
+			// if keep is empty remove previous filter
+			if (keptExprs.size() == 0) {
+				switchChild(filter, opLeftJoin);
+			} else {
+				Op newFilter = OpFilter.filter(keptExprs, opLeftJoin);
+				switchChild(filter, newFilter);
+			}
+		}
+		return opLeftJoin;
+	}
+		
+
+// helpers
+	
+	/**
+	 * get parent of op, never null cause we are using an OpLabel dummy root
+	 * @param op
+	 * @return
+	 */
+	public Op getParent(Op op) {
+		return child2parent.get(op);
+	}
+	
+	/**
+	 * get parent if it's a filter
+	 * @param op
+	 * @return
+	 */
+	public OpFilter getFilterParent(Op op) {
+		Op p = child2parent.get(op);
+		if (p instanceof OpFilter)
+			return (OpFilter) p;
+		else
+			return null;
+	}
+	
+	/** 
+	 * set child of previous to newChild
+	 * 
+	 * @param previous the old child of an operator
+	 * @param newChild the new child to set
+	 * @return parent
+	 */
+	private Op switchChild(Op previous, Op newChild) {
+		Op parent = getParent(previous);
+		
+		if (parent instanceof Op1)
+			((Op1) parent).setSubOp(newChild);
+		
+		else if (parent instanceof Op2) {
+			if (((Op2) parent).getLeft().equals(previous))
+				((Op2) parent).setLeft(newChild);
+			else if (((Op2) parent).getRight().equals(previous))
+				((Op2) parent).setRight(newChild);
+			else
+				throw new RuntimeException("Illegal operation: previous was not a child of parent.");
+		
+		} else if (parent instanceof OpN) {
+			List<Op> newSubs = new ArrayList<Op>();
+			for (Op sub : ((OpN) parent).getElements()) {
+				if (sub.equals(previous))
+					newSubs.add(newChild); // replace prev
+				else
+					newSubs.add(sub); // take over
+			}
+			// new to create a new OpN with new subs
+			Op newOpN = ((OpN) parent).copy(newSubs);
+			Op grandParent = getParent(parent);
+			switchChild(parent, newOpN);
+		
+		} else
+			throw new RuntimeException("Illegal operation: invalid parent operator type.");
+
+		// update child2parent table
+		child2parent.remove(previous);
+		child2parent.put(newChild, parent);
+		return parent;
+	}
+	
+	/**
+	 * @param expr
+	 * @return true if expr can go throw an operator in general
+	 */
+	private boolean canPushDown(Expr expr) {
+		if (expr instanceof E_Exists) // TODO ask AndyS: what else is problematic?
+			return false;
+		return true;
+	}
+	
+	/**
+	 * top-down transform applier
+	 * 
+	 * @author Andreas Langegger <dorgon@users.sf.net>
+	 */
+	class ApplyFilterPushDown extends OpVisitorByType {
+		private Transform transform;
+		
+		/** need another visitor as dispatcher after applying a top-down transform operation */
+		private OpVisitorByType dispatcher;
+		
+		public ApplyFilterPushDown(Transform transform) {
+			this.transform = transform;
+			
+			final ApplyFilterPushDown walker = this;
+			dispatcher = new OpVisitorByType() {
+
+					@Override
+					protected void visit1(Op1 op) {
+						child2parent.put(op.getSubOp(), op);
+						op.getSubOp().visit(walker);
+					}
+
+					@Override
+					protected void visit2(Op2 op) {
+						child2parent.put(op.getLeft(), op);
+						child2parent.put(op.getRight(), op);
+						op.getLeft().visit(walker);
+					}
+
+					@Override
+					protected void visitN(OpN op) {
+						for (Op sub : op.getElements()) {
+							child2parent.put(sub, op);
+							sub.visit(walker);
+						}
+					}
+
+					@Override protected void visit0(Op0 op) {}
+					@Override protected void visitExt(OpExt op) {}
+				};
+		}
+		
+		@Override
+		protected void visit0(Op0 op) {
+			Op x = op.apply(transform);
+			x.visit(dispatcher);
+		}
+	
+		@Override
+		protected void visit1(Op1 op) {
+			Op x = op.apply(transform, op.getSubOp());
+			x.visit(dispatcher);
+		}
+	
+		@Override
+		protected void visit2(Op2 op) {
+			Op x = op.apply(transform, op.getLeft(), op.getRight());
+			x.visit(dispatcher);
+		}
+	
+		@Override
+		protected void visitN(OpN op) {
+			Op x = op.apply(transform, op.getElements());
+			x.visit(dispatcher);
+		}
+	
+		@Override protected void visitExt(OpExt op) {}
+	}	
+}
Index: src/com/hp/hpl/jena/sparql/engine/QueryEngineBase.java
===================================================================
--- src/com/hp/hpl/jena/sparql/engine/QueryEngineBase.java	(revision 6629)
+++ src/com/hp/hpl/jena/sparql/engine/QueryEngineBase.java	(working copy)
@@ -26,7 +26,7 @@
 /** Main part of a QueryEngine - somethign that takes responsibility for a complete query execution */ 
 public abstract class QueryEngineBase implements OpEval, Closeable
 {
-    private DatasetGraph dataset = null ;
+    protected DatasetGraph dataset = null ;
     protected Context context ;
     private Binding startBinding ;
     
@@ -101,7 +101,7 @@
             // Null means setting up but not executing a query.
             queryIterator = eval(op, dataset, startBinding, context) ;
         // This could be an automagic iterator to catch close.
-        return new PlanOp(getOp(), this, queryIterator) ;
+        return new PlanOp(op, this, queryIterator) ; // by AndyL: keep optimized op in plan
     }
     
     protected Op modifyOp(Op op)
Index: src/com/hp/hpl/jena/query/Dataset.java
===================================================================
--- src/com/hp/hpl/jena/query/Dataset.java	(revision 6629)
+++ src/com/hp/hpl/jena/query/Dataset.java	(working copy)
@@ -33,6 +33,12 @@
     /** List the names */
     public Iterator<String> listNames() ;
     
+    /** AndyL: return URL where void description can be found */
+    public String getVoidDescURL() ;
+    
+    /** AndyL: set void description URL */
+    public void setVoidDescURL(String string);
+
     /** Get the lock for this dataset */
     public Lock getLock() ;
     
@@ -43,6 +49,7 @@
      *  The dataset can not be used for query after this call.
      */
     public void close() ;
+
 }
 
 /*
Index: src/com/hp/hpl/jena/sparql/lang/arq/ARQParserTokenManager.java
===================================================================
--- src/com/hp/hpl/jena/sparql/lang/arq/ARQParserTokenManager.java	(revision 6629)
+++ src/com/hp/hpl/jena/sparql/lang/arq/ARQParserTokenManager.java	(working copy)
@@ -5,14 +5,20 @@
  */
 
 package com.hp.hpl.jena.sparql.lang.arq ;
-
-
-
-
-
-
-
-
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import com.hp.hpl.jena.graph.* ;
+import com.hp.hpl.jena.query.* ;
+import com.hp.hpl.jena.sparql.algebra.table.TableN;
+import com.hp.hpl.jena.sparql.core.Var ;
+import com.hp.hpl.jena.sparql.syntax.* ;
+import com.hp.hpl.jena.sparql.expr.* ;
+import com.hp.hpl.jena.sparql.path.* ;
+import com.hp.hpl.jena.sparql.expr.aggregate.* ;
+import com.hp.hpl.jena.sparql.engine.binding.Binding;
+import com.hp.hpl.jena.sparql.engine.binding.BindingMap;
+import com.hp.hpl.jena.sparql.modify.op.* ;
 
 /** Token Manager. */
 public class ARQParserTokenManager implements ARQParserConstants
@@ -48,152 +54,152 @@
          jjmatchedKind = 1;
          return jjMoveNfa_0(0, 0);
       case 33:
-         jjmatchedKind = 114;
-         return jjMoveStringLiteralDfa1_0(0x0L, 0x200000000000L, 0x0L);
+         jjmatchedKind = 118;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x2000000000000L, 0x0L);
       case 38:
-         return jjMoveStringLiteralDfa1_0(0x0L, 0x40000000000000L, 0x0L);
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x400000000000000L, 0x0L);
       case 40:
-         jjmatchedKind = 97;
+         jjmatchedKind = 101;
          return jjMoveNfa_0(0, 0);
       case 41:
-         jjmatchedKind = 98;
+         jjmatchedKind = 102;
          return jjMoveNfa_0(0, 0);
       case 42:
-         jjmatchedKind = 121;
+         jjmatchedKind = 125;
          return jjMoveNfa_0(0, 0);
       case 43:
-         jjmatchedKind = 119;
+         jjmatchedKind = 123;
          return jjMoveNfa_0(0, 0);
       case 44:
-         jjmatchedKind = 106;
+         jjmatchedKind = 110;
          return jjMoveNfa_0(0, 0);
       case 45:
-         jjmatchedKind = 120;
-         return jjMoveStringLiteralDfa1_0(0x0L, 0x0L, 0x1L);
+         jjmatchedKind = 124;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x0L, 0x10L);
       case 46:
-         jjmatchedKind = 107;
+         jjmatchedKind = 111;
          return jjMoveNfa_0(0, 0);
       case 47:
-         jjmatchedKind = 122;
+         jjmatchedKind = 126;
          return jjMoveNfa_0(0, 0);
       case 58:
-         jjmatchedKind = 116;
-         return jjMoveStringLiteralDfa1_0(0x0L, 0x2000000000000000L, 0x0L);
+         jjmatchedKind = 120;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x0L, 0x2L);
       case 59:
-         jjmatchedKind = 105;
+         jjmatchedKind = 109;
          return jjMoveNfa_0(0, 0);
       case 60:
-         jjmatchedKind = 111;
-         return jjMoveStringLiteralDfa1_0(0x0L, 0x1000000000000L, 0x2L);
+         jjmatchedKind = 115;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x10000000000000L, 0x20L);
       case 61:
-         jjmatchedKind = 108;
+         jjmatchedKind = 112;
          return jjMoveNfa_0(0, 0);
       case 62:
-         jjmatchedKind = 110;
-         return jjMoveStringLiteralDfa1_0(0x0L, 0x2000000000000L, 0x0L);
+         jjmatchedKind = 114;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x20000000000000L, 0x0L);
       case 63:
-         jjmatchedKind = 130;
+         jjmatchedKind = 134;
          return jjMoveNfa_0(0, 0);
       case 64:
-         jjmatchedKind = 124;
+         jjmatchedKind = 128;
          return jjMoveNfa_0(0, 0);
       case 65:
-         return jjMoveStringLiteralDfa1_0(0x4220842000000L, 0x80L, 0x0L);
+         return jjMoveStringLiteralDfa1_0(0x42208404000000L, 0x800L, 0x0L);
       case 66:
-         return jjMoveStringLiteralDfa1_0(0x40000020040000L, 0x0L, 0x0L);
+         return jjMoveStringLiteralDfa1_0(0x400000300040000L, 0x0L, 0x0L);
       case 67:
-         return jjMoveStringLiteralDfa1_0(0x400001000000L, 0xc00L, 0x0L);
+         return jjMoveStringLiteralDfa1_0(0x4000002000000L, 0xc000L, 0x0L);
       case 68:
-         return jjMoveStringLiteralDfa1_0(0x100000080a00000L, 0x2060L, 0x0L);
+         return jjMoveStringLiteralDfa1_0(0x1000000811400000L, 0x20600L, 0x0L);
       case 69:
-         return jjMoveStringLiteralDfa1_0(0x10000000000L, 0x0L, 0x0L);
+         return jjMoveStringLiteralDfa1_0(0x100000100000L, 0x0L, 0x0L);
       case 70:
-         return jjMoveStringLiteralDfa1_0(0x30000200000000L, 0x4L, 0x0L);
+         return jjMoveStringLiteralDfa1_0(0x300002000000000L, 0x40L, 0x0L);
       case 71:
-         return jjMoveStringLiteralDfa1_0(0x81000000000L, 0x0L, 0x0L);
+         return jjMoveStringLiteralDfa1_0(0x810000000000L, 0x0L, 0x0L);
       case 72:
-         return jjMoveStringLiteralDfa1_0(0x100000000000L, 0x0L, 0x0L);
+         return jjMoveStringLiteralDfa1_0(0x1000000000000L, 0x0L, 0x0L);
       case 73:
-         return jjMoveStringLiteralDfa1_0(0x7800000000000000L, 0x4010L, 0x0L);
+         return jjMoveStringLiteralDfa1_0(0x8000000000000000L, 0x40107L, 0x0L);
       case 76:
-         return jjMoveStringLiteralDfa1_0(0x600040004000000L, 0x200L, 0x0L);
+         return jjMoveStringLiteralDfa1_0(0x6000400020000000L, 0x2000L, 0x0L);
       case 77:
-         return jjMoveStringLiteralDfa1_0(0x1800000000000L, 0x8L, 0x0L);
+         return jjMoveStringLiteralDfa1_0(0x18000000000000L, 0x80L, 0x0L);
       case 78:
-         return jjMoveStringLiteralDfa1_0(0x100000000L, 0x0L, 0x0L);
+         return jjMoveStringLiteralDfa1_0(0x1000000000L, 0x0L, 0x0L);
       case 79:
-         return jjMoveStringLiteralDfa1_0(0x2018000000L, 0x0L, 0x0L);
+         return jjMoveStringLiteralDfa1_0(0x200c0000000L, 0x0L, 0x0L);
       case 80:
          return jjMoveStringLiteralDfa1_0(0x80000L, 0x0L, 0x0L);
       case 82:
-         return jjMoveStringLiteralDfa1_0(0x8000000000400000L, 0x100L, 0x0L);
+         return jjMoveStringLiteralDfa1_0(0x800000L, 0x1008L, 0x0L);
       case 83:
-         return jjMoveStringLiteralDfa1_0(0x8a008000100000L, 0x1001L, 0x0L);
+         return jjMoveStringLiteralDfa1_0(0x8a0080008200000L, 0x10010L, 0x0L);
       case 84:
-         return jjMoveStringLiteralDfa1_0(0x0L, 0x2L, 0x0L);
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x20L, 0x0L);
       case 85:
-         return jjMoveStringLiteralDfa1_0(0x4000000000L, 0x0L, 0x0L);
+         return jjMoveStringLiteralDfa1_0(0x40000000000L, 0x0L, 0x0L);
       case 87:
-         return jjMoveStringLiteralDfa1_0(0x400000000L, 0x0L, 0x0L);
+         return jjMoveStringLiteralDfa1_0(0x4000000000L, 0x0L, 0x0L);
       case 91:
-         jjmatchedKind = 102;
+         jjmatchedKind = 106;
          return jjMoveNfa_0(0, 0);
       case 93:
-         jjmatchedKind = 103;
+         jjmatchedKind = 107;
          return jjMoveNfa_0(0, 0);
       case 94:
-         jjmatchedKind = 127;
-         return jjMoveStringLiteralDfa1_0(0x0L, 0x800000000000000L, 0x0L);
+         jjmatchedKind = 131;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x8000000000000000L, 0x0L);
       case 97:
          jjmatchedKind = 17;
-         return jjMoveStringLiteralDfa1_0(0x4220842000000L, 0x80L, 0x0L);
+         return jjMoveStringLiteralDfa1_0(0x42208404000000L, 0x800L, 0x0L);
       case 98:
-         return jjMoveStringLiteralDfa1_0(0x40000020040000L, 0x0L, 0x0L);
+         return jjMoveStringLiteralDfa1_0(0x400000300040000L, 0x0L, 0x0L);
       case 99:
-         return jjMoveStringLiteralDfa1_0(0x400001000000L, 0xc00L, 0x0L);
+         return jjMoveStringLiteralDfa1_0(0x4000002000000L, 0xc000L, 0x0L);
       case 100:
-         return jjMoveStringLiteralDfa1_0(0x100000080a00000L, 0x2060L, 0x0L);
+         return jjMoveStringLiteralDfa1_0(0x1000000811400000L, 0x20600L, 0x0L);
       case 101:
-         return jjMoveStringLiteralDfa1_0(0x10000000000L, 0x0L, 0x0L);
+         return jjMoveStringLiteralDfa1_0(0x100000100000L, 0x0L, 0x0L);
       case 102:
-         return jjMoveStringLiteralDfa1_0(0x30000200000000L, 0x4L, 0x0L);
+         return jjMoveStringLiteralDfa1_0(0x300002000000000L, 0x40L, 0x0L);
       case 103:
-         return jjMoveStringLiteralDfa1_0(0x81000000000L, 0x0L, 0x0L);
+         return jjMoveStringLiteralDfa1_0(0x810000000000L, 0x0L, 0x0L);
       case 104:
-         return jjMoveStringLiteralDfa1_0(0x100000000000L, 0x0L, 0x0L);
+         return jjMoveStringLiteralDfa1_0(0x1000000000000L, 0x0L, 0x0L);
       case 105:
-         return jjMoveStringLiteralDfa1_0(0x7800000000000000L, 0x4010L, 0x0L);
+         return jjMoveStringLiteralDfa1_0(0x8000000000000000L, 0x40107L, 0x0L);
       case 108:
-         return jjMoveStringLiteralDfa1_0(0x600040004000000L, 0x200L, 0x0L);
+         return jjMoveStringLiteralDfa1_0(0x6000400020000000L, 0x2000L, 0x0L);
       case 109:
-         return jjMoveStringLiteralDfa1_0(0x1800000000000L, 0x8L, 0x0L);
+         return jjMoveStringLiteralDfa1_0(0x18000000000000L, 0x80L, 0x0L);
       case 110:
-         return jjMoveStringLiteralDfa1_0(0x100000000L, 0x0L, 0x0L);
+         return jjMoveStringLiteralDfa1_0(0x1000000000L, 0x0L, 0x80L);
       case 111:
-         return jjMoveStringLiteralDfa1_0(0x2018000000L, 0x0L, 0x0L);
+         return jjMoveStringLiteralDfa1_0(0x200c0000000L, 0x0L, 0x0L);
       case 112:
          return jjMoveStringLiteralDfa1_0(0x80000L, 0x0L, 0x0L);
       case 114:
-         return jjMoveStringLiteralDfa1_0(0x8000000000400000L, 0x100L, 0x0L);
+         return jjMoveStringLiteralDfa1_0(0x800000L, 0x1008L, 0x0L);
       case 115:
-         return jjMoveStringLiteralDfa1_0(0x8a008000100000L, 0x1001L, 0x0L);
+         return jjMoveStringLiteralDfa1_0(0x8a0080008200000L, 0x10010L, 0x0L);
       case 116:
-         return jjMoveStringLiteralDfa1_0(0x0L, 0x2L, 0x0L);
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x20L, 0x0L);
       case 117:
-         return jjMoveStringLiteralDfa1_0(0x4000000000L, 0x0L, 0x0L);
+         return jjMoveStringLiteralDfa1_0(0x40000000000L, 0x0L, 0x0L);
       case 119:
-         return jjMoveStringLiteralDfa1_0(0x400000000L, 0x0L, 0x0L);
+         return jjMoveStringLiteralDfa1_0(0x4000000000L, 0x0L, 0x0L);
       case 123:
-         jjmatchedKind = 100;
+         jjmatchedKind = 104;
          return jjMoveNfa_0(0, 0);
       case 124:
-         jjmatchedKind = 126;
-         return jjMoveStringLiteralDfa1_0(0x0L, 0x20000000000000L, 0x0L);
+         jjmatchedKind = 130;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x200000000000000L, 0x0L);
       case 125:
-         jjmatchedKind = 101;
+         jjmatchedKind = 105;
          return jjMoveNfa_0(0, 0);
       case 126:
-         jjmatchedKind = 115;
+         jjmatchedKind = 119;
          return jjMoveNfa_0(0, 0);
       default :
          return jjMoveNfa_0(0, 0);
@@ -208,151 +214,151 @@
    switch(curChar)
    {
       case 38:
-         if ((active1 & 0x40000000000000L) != 0L)
+         if ((active1 & 0x400000000000000L) != 0L)
          {
-            jjmatchedKind = 118;
+            jjmatchedKind = 122;
             jjmatchedPos = 1;
          }
          break;
       case 45:
-         if ((active2 & 0x2L) != 0L)
+         if ((active2 & 0x20L) != 0L)
          {
-            jjmatchedKind = 129;
+            jjmatchedKind = 133;
             jjmatchedPos = 1;
          }
          break;
       case 61:
-         if ((active1 & 0x200000000000L) != 0L)
+         if ((active1 & 0x2000000000000L) != 0L)
          {
-            jjmatchedKind = 109;
+            jjmatchedKind = 113;
             jjmatchedPos = 1;
          }
-         else if ((active1 & 0x1000000000000L) != 0L)
+         else if ((active1 & 0x10000000000000L) != 0L)
          {
-            jjmatchedKind = 112;
+            jjmatchedKind = 116;
             jjmatchedPos = 1;
          }
-         else if ((active1 & 0x2000000000000L) != 0L)
+         else if ((active1 & 0x20000000000000L) != 0L)
          {
-            jjmatchedKind = 113;
+            jjmatchedKind = 117;
             jjmatchedPos = 1;
          }
-         else if ((active1 & 0x2000000000000000L) != 0L)
+         else if ((active2 & 0x2L) != 0L)
          {
-            jjmatchedKind = 125;
+            jjmatchedKind = 129;
             jjmatchedPos = 1;
          }
          break;
       case 62:
-         if ((active2 & 0x1L) != 0L)
+         if ((active2 & 0x10L) != 0L)
          {
-            jjmatchedKind = 128;
+            jjmatchedKind = 132;
             jjmatchedPos = 1;
          }
          break;
       case 65:
-         return jjMoveStringLiteralDfa2_0(active0, 0x701100100040000L, active1, 0x45L, active2, 0L);
+         return jjMoveStringLiteralDfa2_0(active0, 0x7011001010040000L, active1, 0x450L, active2, 0L);
       case 68:
-         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x80L, active2, 0L);
+         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x800L, active2, 0L);
       case 69:
-         return jjMoveStringLiteralDfa2_0(active0, 0x8010048080d00000L, active1, 0x120L, active2, 0L);
+         return jjMoveStringLiteralDfa2_0(active0, 0x100480809a00000L, active1, 0x1208L, active2, 0L);
       case 70:
-         return jjMoveStringLiteralDfa2_0(active0, 0x8000000L, active1, 0L, active2, 0L);
+         return jjMoveStringLiteralDfa2_0(active0, 0x40000000L, active1, 0L, active2, 0L);
       case 71:
-         return jjMoveStringLiteralDfa2_0(active0, 0x200000000000L, active1, 0L, active2, 0L);
+         return jjMoveStringLiteralDfa2_0(active0, 0x2000000000000L, active1, 0L, active2, 0L);
       case 72:
-         return jjMoveStringLiteralDfa2_0(active0, 0x400000000L, active1, 0L, active2, 0L);
+         return jjMoveStringLiteralDfa2_0(active0, 0x4000000000L, active1, 0L, active2, 0L);
       case 73:
-         return jjMoveStringLiteralDfa2_0(active0, 0x20800004200000L, active1, 0x1000L, active2, 0L);
+         return jjMoveStringLiteralDfa2_0(active0, 0x208000220400000L, active1, 0x10000L, active2, 0L);
       case 76:
-         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x400L, active2, 0L);
+         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x4000L, active2, 0L);
       case 78:
-         return jjMoveStringLiteralDfa2_0(active0, 0x4800000000L, active1, 0x4010L, active2, 0L);
+         return jjMoveStringLiteralDfa2_0(active0, 0x48000000000L, active1, 0x40100L, active2, 0L);
       case 79:
-         return jjMoveStringLiteralDfa2_0(active0, 0x40400001000000L, active1, 0x208L, active2, 0L);
+         return jjMoveStringLiteralDfa2_0(active0, 0x404000002000000L, active1, 0x2080L, active2, 0L);
       case 80:
-         return jjMoveStringLiteralDfa2_0(active0, 0x2000000000L, active1, 0L, active2, 0L);
+         return jjMoveStringLiteralDfa2_0(active0, 0x20000000000L, active1, 0L, active2, 0L);
       case 82:
-         return jjMoveStringLiteralDfa2_0(active0, 0x81210080000L, active1, 0x2802L, active2, 0L);
+         return jjMoveStringLiteralDfa2_0(active0, 0x812080080000L, active1, 0x28020L, active2, 0L);
       case 83:
-         if ((active0 & 0x20000000000L) != 0L)
+         if ((active0 & 0x200000000000L) != 0L)
          {
-            jjmatchedKind = 41;
+            jjmatchedKind = 45;
             jjmatchedPos = 1;
          }
-         return jjMoveStringLiteralDfa2_0(active0, 0x7800000042000000L, active1, 0L, active2, 0L);
+         return jjMoveStringLiteralDfa2_0(active0, 0x8000000404000000L, active1, 0x7L, active2, 0L);
       case 84:
-         return jjMoveStringLiteralDfa2_0(active0, 0x88000000000000L, active1, 0L, active2, 0L);
+         return jjMoveStringLiteralDfa2_0(active0, 0x880000000000000L, active1, 0L, active2, 0L);
       case 85:
-         return jjMoveStringLiteralDfa2_0(active0, 0x2000000000000L, active1, 0L, active2, 0L);
+         return jjMoveStringLiteralDfa2_0(active0, 0x20000000000000L, active1, 0L, active2, 0L);
       case 86:
-         return jjMoveStringLiteralDfa2_0(active0, 0x4000000000000L, active1, 0L, active2, 0L);
+         return jjMoveStringLiteralDfa2_0(active0, 0x40000000000000L, active1, 0L, active2, 0L);
       case 88:
-         return jjMoveStringLiteralDfa2_0(active0, 0x10000000000L, active1, 0L, active2, 0L);
+         return jjMoveStringLiteralDfa2_0(active0, 0x100000100000L, active1, 0L, active2, 0L);
       case 89:
-         if ((active0 & 0x20000000L) != 0L)
+         if ((active0 & 0x100000000L) != 0L)
          {
-            jjmatchedKind = 29;
+            jjmatchedKind = 32;
             jjmatchedPos = 1;
          }
          break;
       case 94:
-         if ((active1 & 0x800000000000000L) != 0L)
+         if ((active1 & 0x8000000000000000L) != 0L)
          {
-            jjmatchedKind = 123;
+            jjmatchedKind = 127;
             jjmatchedPos = 1;
          }
          break;
       case 97:
-         return jjMoveStringLiteralDfa2_0(active0, 0x701100100040000L, active1, 0x45L, active2, 0L);
+         return jjMoveStringLiteralDfa2_0(active0, 0x7011001010040000L, active1, 0x450L, active2, 0L);
       case 100:
-         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x80L, active2, 0L);
+         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x800L, active2, 0L);
       case 101:
-         return jjMoveStringLiteralDfa2_0(active0, 0x8010048080d00000L, active1, 0x120L, active2, 0L);
+         return jjMoveStringLiteralDfa2_0(active0, 0x100480809a00000L, active1, 0x1208L, active2, 0L);
       case 102:
-         return jjMoveStringLiteralDfa2_0(active0, 0x8000000L, active1, 0L, active2, 0L);
+         return jjMoveStringLiteralDfa2_0(active0, 0x40000000L, active1, 0L, active2, 0L);
       case 103:
-         return jjMoveStringLiteralDfa2_0(active0, 0x200000000000L, active1, 0L, active2, 0L);
+         return jjMoveStringLiteralDfa2_0(active0, 0x2000000000000L, active1, 0L, active2, 0L);
       case 104:
-         return jjMoveStringLiteralDfa2_0(active0, 0x400000000L, active1, 0L, active2, 0L);
+         return jjMoveStringLiteralDfa2_0(active0, 0x4000000000L, active1, 0L, active2, 0L);
       case 105:
-         return jjMoveStringLiteralDfa2_0(active0, 0x20800004200000L, active1, 0x1000L, active2, 0L);
+         return jjMoveStringLiteralDfa2_0(active0, 0x208000220400000L, active1, 0x10000L, active2, 0L);
       case 108:
-         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x400L, active2, 0L);
+         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x4000L, active2, 0L);
       case 110:
-         return jjMoveStringLiteralDfa2_0(active0, 0x4800000000L, active1, 0x4010L, active2, 0L);
+         return jjMoveStringLiteralDfa2_0(active0, 0x48000000000L, active1, 0x40100L, active2, 0L);
       case 111:
-         return jjMoveStringLiteralDfa2_0(active0, 0x40400001000000L, active1, 0x208L, active2, 0L);
+         return jjMoveStringLiteralDfa2_0(active0, 0x404000002000000L, active1, 0x2080L, active2, 0L);
       case 112:
-         return jjMoveStringLiteralDfa2_0(active0, 0x2000000000L, active1, 0L, active2, 0L);
+         return jjMoveStringLiteralDfa2_0(active0, 0x20000000000L, active1, 0L, active2, 0L);
       case 114:
-         return jjMoveStringLiteralDfa2_0(active0, 0x81210080000L, active1, 0x2802L, active2, 0L);
+         return jjMoveStringLiteralDfa2_0(active0, 0x812080080000L, active1, 0x28020L, active2, 0L);
       case 115:
-         if ((active0 & 0x20000000000L) != 0L)
+         if ((active0 & 0x200000000000L) != 0L)
          {
-            jjmatchedKind = 41;
+            jjmatchedKind = 45;
             jjmatchedPos = 1;
          }
-         return jjMoveStringLiteralDfa2_0(active0, 0x7800000042000000L, active1, 0L, active2, 0L);
+         return jjMoveStringLiteralDfa2_0(active0, 0x8000000404000000L, active1, 0x7L, active2, 0L);
       case 116:
-         return jjMoveStringLiteralDfa2_0(active0, 0x88000000000000L, active1, 0L, active2, 0L);
+         return jjMoveStringLiteralDfa2_0(active0, 0x880000000000000L, active1, 0L, active2, 0L);
       case 117:
-         return jjMoveStringLiteralDfa2_0(active0, 0x2000000000000L, active1, 0L, active2, 0L);
+         return jjMoveStringLiteralDfa2_0(active0, 0x20000000000000L, active1, 0L, active2, 0x80L);
       case 118:
-         return jjMoveStringLiteralDfa2_0(active0, 0x4000000000000L, active1, 0L, active2, 0L);
+         return jjMoveStringLiteralDfa2_0(active0, 0x40000000000000L, active1, 0L, active2, 0L);
       case 120:
-         return jjMoveStringLiteralDfa2_0(active0, 0x10000000000L, active1, 0L, active2, 0L);
+         return jjMoveStringLiteralDfa2_0(active0, 0x100000100000L, active1, 0L, active2, 0L);
       case 121:
-         if ((active0 & 0x20000000L) != 0L)
+         if ((active0 & 0x100000000L) != 0L)
          {
-            jjmatchedKind = 29;
+            jjmatchedKind = 32;
             jjmatchedPos = 1;
          }
          break;
       case 124:
-         if ((active1 & 0x20000000000000L) != 0L)
+         if ((active1 & 0x200000000000000L) != 0L)
          {
-            jjmatchedKind = 117;
+            jjmatchedKind = 121;
             jjmatchedPos = 1;
          }
          break;
@@ -372,188 +378,192 @@
    switch(curChar)
    {
       case 65:
-         return jjMoveStringLiteralDfa3_0(active0, 0x1000000000L, active1, 0x200L);
+         return jjMoveStringLiteralDfa3_0(active0, 0x10000000000L, active1, 0x2000L, active2, 0L);
       case 66:
-         return jjMoveStringLiteralDfa3_0(active0, 0x2000000000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa3_0(active0, 0L, active1, 0x2L, active2, 0L);
       case 67:
-         if ((active0 & 0x40000000L) != 0L)
+         if ((active0 & 0x400000000L) != 0L)
          {
-            jjmatchedKind = 30;
+            jjmatchedKind = 34;
             jjmatchedPos = 2;
          }
          break;
       case 68:
-         if ((active0 & 0x800000000L) != 0L)
+         if ((active0 & 0x8000000000L) != 0L)
          {
-            jjmatchedKind = 35;
+            jjmatchedKind = 39;
             jjmatchedPos = 2;
          }
-         else if ((active1 & 0x80L) != 0L)
+         else if ((active1 & 0x800L) != 0L)
          {
-            jjmatchedKind = 71;
+            jjmatchedKind = 75;
             jjmatchedPos = 2;
          }
-         return jjMoveStringLiteralDfa3_0(active0, 0x8000010400000L, active1, 0x8L);
+         return jjMoveStringLiteralDfa3_0(active0, 0x80000080800000L, active1, 0x80L, active2, 0L);
       case 69:
-         return jjMoveStringLiteralDfa3_0(active0, 0x400080000L, active1, 0xc00L);
+         return jjMoveStringLiteralDfa3_0(active0, 0x4000080000L, active1, 0xc000L, active2, 0L);
       case 70:
-         return jjMoveStringLiteralDfa3_0(active0, 0x8000000L, active1, 0L);
+         return jjMoveStringLiteralDfa3_0(active0, 0x40000000L, active1, 0L, active2, 0L);
       case 71:
-         if ((active0 & 0x200000000000L) != 0L)
+         if ((active0 & 0x2000000000000L) != 0L)
          {
-            jjmatchedKind = 45;
+            jjmatchedKind = 49;
             jjmatchedPos = 2;
          }
-         else if ((active0 & 0x4000000000000L) != 0L)
+         else if ((active0 & 0x40000000000000L) != 0L)
          {
-            jjmatchedKind = 50;
+            jjmatchedKind = 54;
             jjmatchedPos = 2;
          }
-         return jjMoveStringLiteralDfa3_0(active0, 0x8000000000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa3_0(active0, 0L, active1, 0x8L, active2, 0L);
       case 73:
-         return jjMoveStringLiteralDfa3_0(active0, 0x1000014000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa3_0(active0, 0x140000000000L, active1, 0x1L, active2, 0L);
       case 75:
-         if ((active0 & 0x2000000L) != 0L)
+         if ((active0 & 0x4000000L) != 0L)
          {
-            jjmatchedKind = 25;
+            jjmatchedKind = 26;
             jjmatchedPos = 2;
          }
          break;
       case 76:
-         return jjMoveStringLiteralDfa3_0(active0, 0x4020000000100000L, active1, 0x1024L);
+         return jjMoveStringLiteralDfa3_0(active0, 0x200000008200000L, active1, 0x10244L, active2, 0L);
       case 77:
-         if ((active0 & 0x2000000000000L) != 0L)
+         if ((active0 & 0x20000000000000L) != 0L)
          {
-            jjmatchedKind = 49;
+            jjmatchedKind = 53;
             jjmatchedPos = 2;
          }
-         return jjMoveStringLiteralDfa3_0(active0, 0x104000000L, active1, 0x101L);
+         return jjMoveStringLiteralDfa3_0(active0, 0x1020000000L, active1, 0x1010L, active2, 0L);
       case 78:
-         if ((active0 & 0x800000000000L) != 0L)
+         if ((active0 & 0x8000000000000L) != 0L)
          {
-            jjmatchedKind = 47;
+            jjmatchedKind = 51;
             jjmatchedPos = 2;
          }
-         return jjMoveStringLiteralDfa3_0(active0, 0x600000001000000L, active1, 0L);
+         return jjMoveStringLiteralDfa3_0(active0, 0x6000000202000000L, active1, 0L, active2, 0L);
       case 79:
-         return jjMoveStringLiteralDfa3_0(active0, 0x80200000000L, active1, 0x2000L);
+         return jjMoveStringLiteralDfa3_0(active0, 0x802000000000L, active1, 0x20000L, active2, 0L);
+      case 80:
+         return jjMoveStringLiteralDfa3_0(active0, 0x100000L, active1, 0L, active2, 0L);
       case 82:
-         if ((active0 & 0x80000000000000L) != 0L)
+         if ((active0 & 0x800000000000000L) != 0L)
          {
-            jjmatchedKind = 55;
+            jjmatchedKind = 59;
             jjmatchedPos = 2;
          }
-         return jjMoveStringLiteralDfa3_0(active0, 0x8000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa3_0(active0, 0x80000000000L, active1, 0L, active2, 0L);
       case 83:
-         return jjMoveStringLiteralDfa3_0(active0, 0x80a40000L, active1, 0x10L);
+         return jjMoveStringLiteralDfa3_0(active0, 0x801440000L, active1, 0x100L, active2, 0L);
       case 84:
-         if ((active0 & 0x40000000000L) != 0L)
+         if ((active0 & 0x400000000000L) != 0L)
          {
-            jjmatchedKind = 42;
+            jjmatchedKind = 46;
             jjmatchedPos = 2;
          }
-         return jjMoveStringLiteralDfa3_0(active0, 0x110002000000000L, active1, 0x4040L);
+         return jjMoveStringLiteralDfa3_0(active0, 0x1100020010000000L, active1, 0x40400L, active2, 0L);
       case 85:
-         return jjMoveStringLiteralDfa3_0(active0, 0x840400000000000L, active1, 0x2L);
+         return jjMoveStringLiteralDfa3_0(active0, 0x8404000000000000L, active1, 0x20L, active2, 0L);
       case 86:
-         return jjMoveStringLiteralDfa3_0(active0, 0x100000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa3_0(active0, 0x1000000000000L, active1, 0L, active2, 0L);
       case 88:
-         if ((active0 & 0x1000000000000L) != 0L)
+         if ((active0 & 0x10000000000000L) != 0L)
          {
-            jjmatchedKind = 48;
+            jjmatchedKind = 52;
             jjmatchedPos = 2;
          }
          break;
       case 97:
-         return jjMoveStringLiteralDfa3_0(active0, 0x1000000000L, active1, 0x200L);
+         return jjMoveStringLiteralDfa3_0(active0, 0x10000000000L, active1, 0x2000L, active2, 0L);
       case 98:
-         return jjMoveStringLiteralDfa3_0(active0, 0x2000000000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa3_0(active0, 0L, active1, 0x2L, active2, 0L);
       case 99:
-         if ((active0 & 0x40000000L) != 0L)
+         if ((active0 & 0x400000000L) != 0L)
          {
-            jjmatchedKind = 30;
+            jjmatchedKind = 34;
             jjmatchedPos = 2;
          }
          break;
       case 100:
-         if ((active0 & 0x800000000L) != 0L)
+         if ((active0 & 0x8000000000L) != 0L)
          {
-            jjmatchedKind = 35;
+            jjmatchedKind = 39;
             jjmatchedPos = 2;
          }
-         else if ((active1 & 0x80L) != 0L)
+         else if ((active1 & 0x800L) != 0L)
          {
-            jjmatchedKind = 71;
+            jjmatchedKind = 75;
             jjmatchedPos = 2;
          }
-         return jjMoveStringLiteralDfa3_0(active0, 0x8000010400000L, active1, 0x8L);
+         return jjMoveStringLiteralDfa3_0(active0, 0x80000080800000L, active1, 0x80L, active2, 0L);
       case 101:
-         return jjMoveStringLiteralDfa3_0(active0, 0x400080000L, active1, 0xc00L);
+         return jjMoveStringLiteralDfa3_0(active0, 0x4000080000L, active1, 0xc000L, active2, 0L);
       case 102:
-         return jjMoveStringLiteralDfa3_0(active0, 0x8000000L, active1, 0L);
+         return jjMoveStringLiteralDfa3_0(active0, 0x40000000L, active1, 0L, active2, 0L);
       case 103:
-         if ((active0 & 0x200000000000L) != 0L)
+         if ((active0 & 0x2000000000000L) != 0L)
          {
-            jjmatchedKind = 45;
+            jjmatchedKind = 49;
             jjmatchedPos = 2;
          }
-         else if ((active0 & 0x4000000000000L) != 0L)
+         else if ((active0 & 0x40000000000000L) != 0L)
          {
-            jjmatchedKind = 50;
+            jjmatchedKind = 54;
             jjmatchedPos = 2;
          }
-         return jjMoveStringLiteralDfa3_0(active0, 0x8000000000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa3_0(active0, 0L, active1, 0x8L, active2, 0L);
       case 105:
-         return jjMoveStringLiteralDfa3_0(active0, 0x1000014000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa3_0(active0, 0x140000000000L, active1, 0x1L, active2, 0L);
       case 107:
-         if ((active0 & 0x2000000L) != 0L)
+         if ((active0 & 0x4000000L) != 0L)
          {
-            jjmatchedKind = 25;
+            jjmatchedKind = 26;
             jjmatchedPos = 2;
          }
          break;
       case 108:
-         return jjMoveStringLiteralDfa3_0(active0, 0x4020000000100000L, active1, 0x1024L);
+         return jjMoveStringLiteralDfa3_0(active0, 0x200000008200000L, active1, 0x10244L, active2, 0x80L);
       case 109:
-         if ((active0 & 0x2000000000000L) != 0L)
+         if ((active0 & 0x20000000000000L) != 0L)
          {
-            jjmatchedKind = 49;
+            jjmatchedKind = 53;
             jjmatchedPos = 2;
          }
-         return jjMoveStringLiteralDfa3_0(active0, 0x104000000L, active1, 0x101L);
+         return jjMoveStringLiteralDfa3_0(active0, 0x1020000000L, active1, 0x1010L, active2, 0L);
       case 110:
-         if ((active0 & 0x800000000000L) != 0L)
+         if ((active0 & 0x8000000000000L) != 0L)
          {
-            jjmatchedKind = 47;
+            jjmatchedKind = 51;
             jjmatchedPos = 2;
          }
-         return jjMoveStringLiteralDfa3_0(active0, 0x600000001000000L, active1, 0L);
+         return jjMoveStringLiteralDfa3_0(active0, 0x6000000202000000L, active1, 0L, active2, 0L);
       case 111:
-         return jjMoveStringLiteralDfa3_0(active0, 0x80200000000L, active1, 0x2000L);
+         return jjMoveStringLiteralDfa3_0(active0, 0x802000000000L, active1, 0x20000L, active2, 0L);
+      case 112:
+         return jjMoveStringLiteralDfa3_0(active0, 0x100000L, active1, 0L, active2, 0L);
       case 114:
-         if ((active0 & 0x80000000000000L) != 0L)
+         if ((active0 & 0x800000000000000L) != 0L)
          {
-            jjmatchedKind = 55;
+            jjmatchedKind = 59;
             jjmatchedPos = 2;
          }
-         return jjMoveStringLiteralDfa3_0(active0, 0x8000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa3_0(active0, 0x80000000000L, active1, 0L, active2, 0L);
       case 115:
-         return jjMoveStringLiteralDfa3_0(active0, 0x80a40000L, active1, 0x10L);
+         return jjMoveStringLiteralDfa3_0(active0, 0x801440000L, active1, 0x100L, active2, 0L);
       case 116:
-         if ((active0 & 0x40000000000L) != 0L)
+         if ((active0 & 0x400000000000L) != 0L)
          {
-            jjmatchedKind = 42;
+            jjmatchedKind = 46;
             jjmatchedPos = 2;
          }
-         return jjMoveStringLiteralDfa3_0(active0, 0x110002000000000L, active1, 0x4040L);
+         return jjMoveStringLiteralDfa3_0(active0, 0x1100020010000000L, active1, 0x40400L, active2, 0L);
       case 117:
-         return jjMoveStringLiteralDfa3_0(active0, 0x840400000000000L, active1, 0x2L);
+         return jjMoveStringLiteralDfa3_0(active0, 0x8404000000000000L, active1, 0x20L, active2, 0L);
       case 118:
-         return jjMoveStringLiteralDfa3_0(active0, 0x100000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa3_0(active0, 0x1000000000000L, active1, 0L, active2, 0L);
       case 120:
-         if ((active0 & 0x1000000000000L) != 0L)
+         if ((active0 & 0x10000000000000L) != 0L)
          {
-            jjmatchedKind = 48;
+            jjmatchedKind = 52;
             jjmatchedPos = 2;
          }
          break;
@@ -562,9 +572,9 @@
    }
    return jjMoveNfa_0(0, 2);
 }
-private int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1)
+private int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1, long old2, long active2)
 {
-   if (((active0 &= old0) | (active1 &= old1)) == 0L)
+   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)
       return jjMoveNfa_0(0, 2);
    try { curChar = input_stream.readChar(); }
    catch(java.io.IOException e) {
@@ -573,171 +583,186 @@
    switch(curChar)
    {
       case 65:
-         if ((active1 & 0x40L) != 0L)
+         if ((active1 & 0x400L) != 0L)
          {
-            jjmatchedKind = 70;
+            jjmatchedKind = 74;
             jjmatchedPos = 3;
          }
-         return jjMoveStringLiteralDfa4_0(active0, 0x100000000000000L, active1, 0xc00L);
+         return jjMoveStringLiteralDfa4_0(active0, 0x1000000010000000L, active1, 0xc000L, active2, 0L);
       case 67:
-         if ((active0 & 0x80000000L) != 0L)
+         if ((active0 & 0x800000000L) != 0L)
          {
-            jjmatchedKind = 31;
+            jjmatchedKind = 35;
             jjmatchedPos = 3;
          }
-         return jjMoveStringLiteralDfa4_0(active0, 0x10000000800000L, active1, 0L);
+         return jjMoveStringLiteralDfa4_0(active0, 0x100000001000000L, active1, 0L, active2, 0L);
       case 68:
-         if ((active1 & 0x200L) != 0L)
+         if ((active1 & 0x2000L) != 0L)
          {
-            jjmatchedKind = 73;
+            jjmatchedKind = 77;
             jjmatchedPos = 3;
          }
-         break;
+         return jjMoveStringLiteralDfa4_0(active0, 0x200000000L, active1, 0L, active2, 0L);
       case 69:
          if ((active0 & 0x40000L) != 0L)
          {
             jjmatchedKind = 18;
             jjmatchedPos = 3;
          }
-         else if ((active1 & 0x2L) != 0L)
+         else if ((active1 & 0x20L) != 0L)
          {
-            jjmatchedKind = 65;
+            jjmatchedKind = 69;
             jjmatchedPos = 3;
          }
-         return jjMoveStringLiteralDfa4_0(active0, 0x8008000110100000L, active1, 0x1031L);
+         return jjMoveStringLiteralDfa4_0(active0, 0x80001080200000L, active1, 0x10318L, active2, 0L);
       case 70:
-         return jjMoveStringLiteralDfa4_0(active0, 0x80000L, active1, 0L);
+         if ((active0 & 0x8000000L) != 0L)
+         {
+            jjmatchedKind = 27;
+            jjmatchedPos = 3;
+         }
+         return jjMoveStringLiteralDfa4_0(active0, 0x80000L, active1, 0L, active2, 0L);
       case 71:
-         if ((active0 & 0x200000000000000L) != 0L)
+         if ((active0 & 0x2000000000000000L) != 0L)
          {
-            jjmatchedKind = 57;
+            jjmatchedKind = 61;
             jjmatchedPos = 3;
          }
-         return jjMoveStringLiteralDfa4_0(active0, 0x400000000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa4_0(active0, 0x4000000000000000L, active1, 0L, active2, 0L);
       case 73:
-         return jjMoveStringLiteralDfa4_0(active0, 0x4000102004000000L, active1, 0x8L);
+         return jjMoveStringLiteralDfa4_0(active0, 0x1020020000000L, active1, 0x84L, active2, 0L);
       case 76:
-         return jjMoveStringLiteralDfa4_0(active0, 0x2000000000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa4_0(active0, 0x100000L, active1, 0x2L, active2, 0L);
       case 77:
-         if ((active0 & 0x200000000L) != 0L)
+         if ((active0 & 0x2000000000L) != 0L)
          {
-            jjmatchedKind = 33;
+            jjmatchedKind = 37;
             jjmatchedPos = 3;
          }
          break;
       case 78:
-         return jjMoveStringLiteralDfa4_0(active0, 0x40400000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa4_0(active0, 0x404000000000000L, active1, 0L, active2, 0L);
       case 79:
-         if ((active1 & 0x4000L) != 0L)
+         if ((active1 & 0x40000L) != 0L)
          {
-            jjmatchedKind = 78;
+            jjmatchedKind = 82;
             jjmatchedPos = 3;
          }
-         return jjMoveStringLiteralDfa4_0(active0, 0x4000000000L, active1, 0x100L);
+         return jjMoveStringLiteralDfa4_0(active0, 0x40000000000L, active1, 0x1000L, active2, 0L);
       case 80:
-         if ((active1 & 0x2000L) != 0L)
+         if ((active1 & 0x20000L) != 0L)
          {
-            jjmatchedKind = 77;
+            jjmatchedKind = 81;
             jjmatchedPos = 3;
          }
-         return jjMoveStringLiteralDfa4_0(active0, 0x1000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa4_0(active0, 0x10000000000L, active1, 0L, active2, 0L);
       case 82:
-         return jjMoveStringLiteralDfa4_0(active0, 0x1800000400000000L, active1, 0L);
+         return jjMoveStringLiteralDfa4_0(active0, 0x8000004000000000L, active1, 0x1L, active2, 0L);
       case 83:
-         return jjMoveStringLiteralDfa4_0(active0, 0x10009000000L, active1, 0x4L);
+         return jjMoveStringLiteralDfa4_0(active0, 0x100042000000L, active1, 0x40L, active2, 0L);
       case 84:
-         return jjMoveStringLiteralDfa4_0(active0, 0x20000000200000L, active1, 0L);
+         return jjMoveStringLiteralDfa4_0(active0, 0x200000000400000L, active1, 0L, active2, 0L);
       case 85:
-         return jjMoveStringLiteralDfa4_0(active0, 0x80000400000L, active1, 0L);
+         return jjMoveStringLiteralDfa4_0(active0, 0x800000800000L, active1, 0L, active2, 0L);
       case 86:
-         return jjMoveStringLiteralDfa4_0(active0, 0x8000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa4_0(active0, 0x80000000000L, active1, 0L, active2, 0L);
       case 97:
-         if ((active1 & 0x40L) != 0L)
+         if ((active1 & 0x400L) != 0L)
          {
-            jjmatchedKind = 70;
+            jjmatchedKind = 74;
             jjmatchedPos = 3;
          }
-         return jjMoveStringLiteralDfa4_0(active0, 0x100000000000000L, active1, 0xc00L);
+         return jjMoveStringLiteralDfa4_0(active0, 0x1000000010000000L, active1, 0xc000L, active2, 0L);
       case 99:
-         if ((active0 & 0x80000000L) != 0L)
+         if ((active0 & 0x800000000L) != 0L)
          {
-            jjmatchedKind = 31;
+            jjmatchedKind = 35;
             jjmatchedPos = 3;
          }
-         return jjMoveStringLiteralDfa4_0(active0, 0x10000000800000L, active1, 0L);
+         return jjMoveStringLiteralDfa4_0(active0, 0x100000001000000L, active1, 0L, active2, 0L);
       case 100:
-         if ((active1 & 0x200L) != 0L)
+         if ((active1 & 0x2000L) != 0L)
          {
-            jjmatchedKind = 73;
+            jjmatchedKind = 77;
             jjmatchedPos = 3;
          }
-         break;
+         return jjMoveStringLiteralDfa4_0(active0, 0x200000000L, active1, 0L, active2, 0L);
       case 101:
          if ((active0 & 0x40000L) != 0L)
          {
             jjmatchedKind = 18;
             jjmatchedPos = 3;
          }
-         else if ((active1 & 0x2L) != 0L)
+         else if ((active1 & 0x20L) != 0L)
          {
-            jjmatchedKind = 65;
+            jjmatchedKind = 69;
             jjmatchedPos = 3;
          }
-         return jjMoveStringLiteralDfa4_0(active0, 0x8008000110100000L, active1, 0x1031L);
+         return jjMoveStringLiteralDfa4_0(active0, 0x80001080200000L, active1, 0x10318L, active2, 0L);
       case 102:
-         return jjMoveStringLiteralDfa4_0(active0, 0x80000L, active1, 0L);
+         if ((active0 & 0x8000000L) != 0L)
+         {
+            jjmatchedKind = 27;
+            jjmatchedPos = 3;
+         }
+         return jjMoveStringLiteralDfa4_0(active0, 0x80000L, active1, 0L, active2, 0L);
       case 103:
-         if ((active0 & 0x200000000000000L) != 0L)
+         if ((active0 & 0x2000000000000000L) != 0L)
          {
-            jjmatchedKind = 57;
+            jjmatchedKind = 61;
             jjmatchedPos = 3;
          }
-         return jjMoveStringLiteralDfa4_0(active0, 0x400000000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa4_0(active0, 0x4000000000000000L, active1, 0L, active2, 0L);
       case 105:
-         return jjMoveStringLiteralDfa4_0(active0, 0x4000102004000000L, active1, 0x8L);
+         return jjMoveStringLiteralDfa4_0(active0, 0x1020020000000L, active1, 0x84L, active2, 0L);
       case 108:
-         return jjMoveStringLiteralDfa4_0(active0, 0x2000000000000000L, active1, 0L);
+         if ((active2 & 0x80L) != 0L)
+         {
+            jjmatchedKind = 135;
+            jjmatchedPos = 3;
+         }
+         return jjMoveStringLiteralDfa4_0(active0, 0x100000L, active1, 0x2L, active2, 0L);
       case 109:
-         if ((active0 & 0x200000000L) != 0L)
+         if ((active0 & 0x2000000000L) != 0L)
          {
-            jjmatchedKind = 33;
+            jjmatchedKind = 37;
             jjmatchedPos = 3;
          }
          break;
       case 110:
-         return jjMoveStringLiteralDfa4_0(active0, 0x40400000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa4_0(active0, 0x404000000000000L, active1, 0L, active2, 0L);
       case 111:
-         if ((active1 & 0x4000L) != 0L)
+         if ((active1 & 0x40000L) != 0L)
          {
-            jjmatchedKind = 78;
+            jjmatchedKind = 82;
             jjmatchedPos = 3;
          }
-         return jjMoveStringLiteralDfa4_0(active0, 0x4000000000L, active1, 0x100L);
+         return jjMoveStringLiteralDfa4_0(active0, 0x40000000000L, active1, 0x1000L, active2, 0L);
       case 112:
-         if ((active1 & 0x2000L) != 0L)
+         if ((active1 & 0x20000L) != 0L)
          {
-            jjmatchedKind = 77;
+            jjmatchedKind = 81;
             jjmatchedPos = 3;
          }
-         return jjMoveStringLiteralDfa4_0(active0, 0x1000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa4_0(active0, 0x10000000000L, active1, 0L, active2, 0L);
       case 114:
-         return jjMoveStringLiteralDfa4_0(active0, 0x1800000400000000L, active1, 0L);
+         return jjMoveStringLiteralDfa4_0(active0, 0x8000004000000000L, active1, 0x1L, active2, 0L);
       case 115:
-         return jjMoveStringLiteralDfa4_0(active0, 0x10009000000L, active1, 0x4L);
+         return jjMoveStringLiteralDfa4_0(active0, 0x100042000000L, active1, 0x40L, active2, 0L);
       case 116:
-         return jjMoveStringLiteralDfa4_0(active0, 0x20000000200000L, active1, 0L);
+         return jjMoveStringLiteralDfa4_0(active0, 0x200000000400000L, active1, 0L, active2, 0L);
       case 117:
-         return jjMoveStringLiteralDfa4_0(active0, 0x80000400000L, active1, 0L);
+         return jjMoveStringLiteralDfa4_0(active0, 0x800000800000L, active1, 0L, active2, 0L);
       case 118:
-         return jjMoveStringLiteralDfa4_0(active0, 0x8000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa4_0(active0, 0x80000000000L, active1, 0L, active2, 0L);
       default :
          break;
    }
    return jjMoveNfa_0(0, 3);
 }
-private int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1)
+private int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1, long old2, long active2)
 {
-   if (((active0 &= old0) | (active1 &= old1)) == 0L)
+   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)
       return jjMoveNfa_0(0, 3);
    try { curChar = input_stream.readChar(); }
    catch(java.io.IOException e) {
@@ -746,222 +771,226 @@
    switch(curChar)
    {
       case 65:
-         return jjMoveStringLiteralDfa5_0(active0, 0x2000000000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa5_0(active0, 0x100000L, active1, 0x2L);
       case 67:
-         return jjMoveStringLiteralDfa5_0(active0, 0x500000L, active1, 0L);
+         return jjMoveStringLiteralDfa5_0(active0, 0xa00000L, active1, 0L);
       case 68:
-         if ((active0 & 0x100000000L) != 0L)
+         if ((active0 & 0x1000000000L) != 0L)
          {
-            jjmatchedKind = 32;
+            jjmatchedKind = 36;
             jjmatchedPos = 4;
          }
-         else if ((active0 & 0x40000000000000L) != 0L)
+         else if ((active0 & 0x400000000000000L) != 0L)
          {
-            jjmatchedKind = 54;
+            jjmatchedKind = 58;
             jjmatchedPos = 4;
          }
          break;
       case 69:
-         if ((active0 & 0x400000000L) != 0L)
+         if ((active0 & 0x4000000000L) != 0L)
          {
-            jjmatchedKind = 34;
+            jjmatchedKind = 38;
             jjmatchedPos = 4;
          }
-         else if ((active1 & 0x4L) != 0L)
+         else if ((active1 & 0x40L) != 0L)
          {
-            jjmatchedKind = 66;
+            jjmatchedKind = 70;
             jjmatchedPos = 4;
          }
-         return jjMoveStringLiteralDfa5_0(active0, 0x20000008000000L, active1, 0L);
+         return jjMoveStringLiteralDfa5_0(active0, 0x200000040000000L, active1, 0L);
       case 70:
-         return jjMoveStringLiteralDfa5_0(active0, 0L, active1, 0x8L);
+         return jjMoveStringLiteralDfa5_0(active0, 0L, active1, 0x80L);
       case 72:
-         if ((active0 & 0x1000000000L) != 0L)
+         if ((active0 & 0x10000000000L) != 0L)
          {
-            jjmatchedKind = 36;
+            jjmatchedKind = 40;
             jjmatchedPos = 4;
          }
-         else if ((active0 & 0x10000000000000L) != 0L)
+         else if ((active0 & 0x100000000000000L) != 0L)
          {
-            jjmatchedKind = 52;
+            jjmatchedKind = 56;
             jjmatchedPos = 4;
          }
          break;
       case 73:
-         if ((active0 & 0x800000000000000L) != 0L)
+         if ((active0 & 0x8000000000000000L) != 0L)
          {
-            jjmatchedKind = 59;
+            jjmatchedKind = 63;
             jjmatchedPos = 4;
          }
-         else if ((active0 & 0x1000000000000000L) != 0L)
+         else if ((active1 & 0x1L) != 0L)
          {
-            jjmatchedKind = 60;
+            jjmatchedKind = 64;
             jjmatchedPos = 4;
          }
-         return jjMoveStringLiteralDfa5_0(active0, 0x8000280000L, active1, 0L);
+         return jjMoveStringLiteralDfa5_0(active0, 0x80200480000L, active1, 0L);
       case 77:
-         return jjMoveStringLiteralDfa5_0(active0, 0x400000000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa5_0(active0, 0x4000000000000000L, active1, 0L);
       case 78:
-         if ((active0 & 0x4000000000L) != 0L)
+         if ((active0 & 0x40000000000L) != 0L)
          {
-            jjmatchedKind = 38;
+            jjmatchedKind = 42;
             jjmatchedPos = 4;
          }
-         return jjMoveStringLiteralDfa5_0(active0, 0x100000000000L, active1, 0x1000L);
+         return jjMoveStringLiteralDfa5_0(active0, 0x1000000000000L, active1, 0x10000L);
       case 79:
-         return jjMoveStringLiteralDfa5_0(active0, 0x2000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa5_0(active0, 0x20000000000L, active1, 0L);
       case 80:
-         if ((active0 & 0x80000000000L) != 0L)
+         if ((active0 & 0x800000000000L) != 0L)
          {
-            jjmatchedKind = 43;
+            jjmatchedKind = 47;
             jjmatchedPos = 4;
          }
          break;
       case 82:
-         if ((active0 & 0x10000000L) != 0L)
+         if ((active0 & 0x80000000L) != 0L)
          {
-            jjmatchedKind = 28;
+            jjmatchedKind = 31;
             jjmatchedPos = 4;
          }
-         else if ((active1 & 0x400L) != 0L)
+         else if ((active1 & 0x4000L) != 0L)
          {
-            jjmatchedKind = 74;
+            jjmatchedKind = 78;
             jjmatchedPos = 4;
          }
-         return jjMoveStringLiteralDfa5_0(active0, 0x800000L, active1, 0x10L);
+         return jjMoveStringLiteralDfa5_0(active0, 0x1000000L, active1, 0x100L);
+      case 83:
+         return jjMoveStringLiteralDfa5_0(active0, 0x10000000L, active1, 0L);
       case 84:
-         if ((active0 & 0x4000000L) != 0L)
+         if ((active0 & 0x20000000L) != 0L)
          {
-            jjmatchedKind = 26;
+            jjmatchedKind = 29;
             jjmatchedPos = 4;
          }
-         else if ((active0 & 0x400000000000L) != 0L)
+         else if ((active0 & 0x4000000000000L) != 0L)
          {
-            jjmatchedKind = 46;
+            jjmatchedKind = 50;
             jjmatchedPos = 4;
          }
-         return jjMoveStringLiteralDfa5_0(active0, 0x4100010001000000L, active1, 0x821L);
+         return jjMoveStringLiteralDfa5_0(active0, 0x1000100002000000L, active1, 0x8214L);
       case 86:
-         if ((active0 & 0x8000000000000L) != 0L)
+         if ((active0 & 0x80000000000000L) != 0L)
          {
-            jjmatchedKind = 51;
+            jjmatchedKind = 55;
             jjmatchedPos = 4;
          }
-         return jjMoveStringLiteralDfa5_0(active0, 0L, active1, 0x100L);
+         return jjMoveStringLiteralDfa5_0(active0, 0L, active1, 0x1000L);
       case 88:
-         if ((active0 & 0x8000000000000000L) != 0L)
+         if ((active1 & 0x8L) != 0L)
          {
-            jjmatchedKind = 63;
+            jjmatchedKind = 67;
             jjmatchedPos = 4;
          }
          break;
       case 97:
-         return jjMoveStringLiteralDfa5_0(active0, 0x2000000000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa5_0(active0, 0x100000L, active1, 0x2L);
       case 99:
-         return jjMoveStringLiteralDfa5_0(active0, 0x500000L, active1, 0L);
+         return jjMoveStringLiteralDfa5_0(active0, 0xa00000L, active1, 0L);
       case 100:
-         if ((active0 & 0x100000000L) != 0L)
+         if ((active0 & 0x1000000000L) != 0L)
          {
-            jjmatchedKind = 32;
+            jjmatchedKind = 36;
             jjmatchedPos = 4;
          }
-         else if ((active0 & 0x40000000000000L) != 0L)
+         else if ((active0 & 0x400000000000000L) != 0L)
          {
-            jjmatchedKind = 54;
+            jjmatchedKind = 58;
             jjmatchedPos = 4;
          }
          break;
       case 101:
-         if ((active0 & 0x400000000L) != 0L)
+         if ((active0 & 0x4000000000L) != 0L)
          {
-            jjmatchedKind = 34;
+            jjmatchedKind = 38;
             jjmatchedPos = 4;
          }
-         else if ((active1 & 0x4L) != 0L)
+         else if ((active1 & 0x40L) != 0L)
          {
-            jjmatchedKind = 66;
+            jjmatchedKind = 70;
             jjmatchedPos = 4;
          }
-         return jjMoveStringLiteralDfa5_0(active0, 0x20000008000000L, active1, 0L);
+         return jjMoveStringLiteralDfa5_0(active0, 0x200000040000000L, active1, 0L);
       case 102:
-         return jjMoveStringLiteralDfa5_0(active0, 0L, active1, 0x8L);
+         return jjMoveStringLiteralDfa5_0(active0, 0L, active1, 0x80L);
       case 104:
-         if ((active0 & 0x1000000000L) != 0L)
+         if ((active0 & 0x10000000000L) != 0L)
          {
-            jjmatchedKind = 36;
+            jjmatchedKind = 40;
             jjmatchedPos = 4;
          }
-         else if ((active0 & 0x10000000000000L) != 0L)
+         else if ((active0 & 0x100000000000000L) != 0L)
          {
-            jjmatchedKind = 52;
+            jjmatchedKind = 56;
             jjmatchedPos = 4;
          }
          break;
       case 105:
-         if ((active0 & 0x800000000000000L) != 0L)
+         if ((active0 & 0x8000000000000000L) != 0L)
          {
-            jjmatchedKind = 59;
+            jjmatchedKind = 63;
             jjmatchedPos = 4;
          }
-         else if ((active0 & 0x1000000000000000L) != 0L)
+         else if ((active1 & 0x1L) != 0L)
          {
-            jjmatchedKind = 60;
+            jjmatchedKind = 64;
             jjmatchedPos = 4;
          }
-         return jjMoveStringLiteralDfa5_0(active0, 0x8000280000L, active1, 0L);
+         return jjMoveStringLiteralDfa5_0(active0, 0x80200480000L, active1, 0L);
       case 109:
-         return jjMoveStringLiteralDfa5_0(active0, 0x400000000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa5_0(active0, 0x4000000000000000L, active1, 0L);
       case 110:
-         if ((active0 & 0x4000000000L) != 0L)
+         if ((active0 & 0x40000000000L) != 0L)
          {
-            jjmatchedKind = 38;
+            jjmatchedKind = 42;
             jjmatchedPos = 4;
          }
-         return jjMoveStringLiteralDfa5_0(active0, 0x100000000000L, active1, 0x1000L);
+         return jjMoveStringLiteralDfa5_0(active0, 0x1000000000000L, active1, 0x10000L);
       case 111:
-         return jjMoveStringLiteralDfa5_0(active0, 0x2000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa5_0(active0, 0x20000000000L, active1, 0L);
       case 112:
-         if ((active0 & 0x80000000000L) != 0L)
+         if ((active0 & 0x800000000000L) != 0L)
          {
-            jjmatchedKind = 43;
+            jjmatchedKind = 47;
             jjmatchedPos = 4;
          }
          break;
       case 114:
-         if ((active0 & 0x10000000L) != 0L)
+         if ((active0 & 0x80000000L) != 0L)
          {
-            jjmatchedKind = 28;
+            jjmatchedKind = 31;
             jjmatchedPos = 4;
          }
-         else if ((active1 & 0x400L) != 0L)
+         else if ((active1 & 0x4000L) != 0L)
          {
-            jjmatchedKind = 74;
+            jjmatchedKind = 78;
             jjmatchedPos = 4;
          }
-         return jjMoveStringLiteralDfa5_0(active0, 0x800000L, active1, 0x10L);
+         return jjMoveStringLiteralDfa5_0(active0, 0x1000000L, active1, 0x100L);
+      case 115:
+         return jjMoveStringLiteralDfa5_0(active0, 0x10000000L, active1, 0L);
       case 116:
-         if ((active0 & 0x4000000L) != 0L)
+         if ((active0 & 0x20000000L) != 0L)
          {
-            jjmatchedKind = 26;
+            jjmatchedKind = 29;
             jjmatchedPos = 4;
          }
-         else if ((active0 & 0x400000000000L) != 0L)
+         else if ((active0 & 0x4000000000000L) != 0L)
          {
-            jjmatchedKind = 46;
+            jjmatchedKind = 50;
             jjmatchedPos = 4;
          }
-         return jjMoveStringLiteralDfa5_0(active0, 0x4100010001000000L, active1, 0x821L);
+         return jjMoveStringLiteralDfa5_0(active0, 0x1000100002000000L, active1, 0x8214L);
       case 118:
-         if ((active0 & 0x8000000000000L) != 0L)
+         if ((active0 & 0x80000000000000L) != 0L)
          {
-            jjmatchedKind = 51;
+            jjmatchedKind = 55;
             jjmatchedPos = 4;
          }
-         return jjMoveStringLiteralDfa5_0(active0, 0L, active1, 0x100L);
+         return jjMoveStringLiteralDfa5_0(active0, 0L, active1, 0x1000L);
       case 120:
-         if ((active0 & 0x8000000000000000L) != 0L)
+         if ((active1 & 0x8L) != 0L)
          {
-            jjmatchedKind = 63;
+            jjmatchedKind = 67;
             jjmatchedPos = 4;
          }
          break;
@@ -981,70 +1010,70 @@
    switch(curChar)
    {
       case 65:
-         return jjMoveStringLiteralDfa6_0(active0, 0x400000000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa6_0(active0, 0x4000000000000000L, active1, 0L);
       case 67:
-         return jjMoveStringLiteralDfa6_0(active0, 0x8000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa6_0(active0, 0x80000000000L, active1, 0L);
       case 69:
-         if ((active1 & 0x20L) != 0L)
+         if ((active1 & 0x200L) != 0L)
          {
-            jjmatchedKind = 69;
+            jjmatchedKind = 73;
             jjmatchedPos = 5;
          }
-         else if ((active1 & 0x100L) != 0L)
+         else if ((active1 & 0x1000L) != 0L)
          {
-            jjmatchedKind = 72;
+            jjmatchedKind = 76;
             jjmatchedPos = 5;
          }
-         else if ((active1 & 0x800L) != 0L)
+         else if ((active1 & 0x8000L) != 0L)
          {
-            jjmatchedKind = 75;
+            jjmatchedKind = 79;
             jjmatchedPos = 5;
          }
-         return jjMoveStringLiteralDfa6_0(active0, 0x4000000000400000L, active1, 0x1L);
+         return jjMoveStringLiteralDfa6_0(active0, 0x10800000L, active1, 0x14L);
       case 71:
-         if ((active0 & 0x100000000000L) != 0L)
+         if ((active0 & 0x1000000000000L) != 0L)
          {
-            jjmatchedKind = 44;
+            jjmatchedKind = 48;
             jjmatchedPos = 5;
          }
          break;
       case 73:
-         return jjMoveStringLiteralDfa6_0(active0, 0x800000L, active1, 0L);
+         return jjMoveStringLiteralDfa6_0(active0, 0x1100000L, active1, 0L);
       case 78:
-         return jjMoveStringLiteralDfa6_0(active0, 0x2000002000200000L, active1, 0L);
+         return jjMoveStringLiteralDfa6_0(active0, 0x20200400000L, active1, 0x2L);
       case 82:
-         if ((active0 & 0x20000000000000L) != 0L)
+         if ((active0 & 0x200000000000000L) != 0L)
          {
-            jjmatchedKind = 53;
+            jjmatchedKind = 57;
             jjmatchedPos = 5;
          }
-         return jjMoveStringLiteralDfa6_0(active0, 0x1000000L, active1, 0L);
+         return jjMoveStringLiteralDfa6_0(active0, 0x2000000L, active1, 0L);
       case 83:
-         if ((active0 & 0x10000000000L) != 0L)
+         if ((active0 & 0x100000000000L) != 0L)
          {
-            jjmatchedKind = 40;
+            jjmatchedKind = 44;
             jjmatchedPos = 5;
          }
          break;
       case 84:
-         if ((active0 & 0x100000L) != 0L)
+         if ((active0 & 0x200000L) != 0L)
          {
-            jjmatchedKind = 20;
+            jjmatchedKind = 21;
             jjmatchedPos = 5;
          }
-         else if ((active0 & 0x8000000L) != 0L)
+         else if ((active0 & 0x40000000L) != 0L)
          {
-            jjmatchedKind = 27;
+            jjmatchedKind = 30;
             jjmatchedPos = 5;
          }
-         else if ((active1 & 0x10L) != 0L)
+         else if ((active1 & 0x100L) != 0L)
          {
-            jjmatchedKind = 68;
+            jjmatchedKind = 72;
             jjmatchedPos = 5;
          }
-         else if ((active1 & 0x1000L) != 0L)
+         else if ((active1 & 0x10000L) != 0L)
          {
-            jjmatchedKind = 76;
+            jjmatchedKind = 80;
             jjmatchedPos = 5;
          }
          break;
@@ -1056,77 +1085,77 @@
          }
          break;
       case 89:
-         if ((active1 & 0x8L) != 0L)
+         if ((active1 & 0x80L) != 0L)
          {
-            jjmatchedKind = 67;
+            jjmatchedKind = 71;
             jjmatchedPos = 5;
          }
-         return jjMoveStringLiteralDfa6_0(active0, 0x100000000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa6_0(active0, 0x1000000000000000L, active1, 0L);
       case 97:
-         return jjMoveStringLiteralDfa6_0(active0, 0x400000000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa6_0(active0, 0x4000000000000000L, active1, 0L);
       case 99:
-         return jjMoveStringLiteralDfa6_0(active0, 0x8000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa6_0(active0, 0x80000000000L, active1, 0L);
       case 101:
-         if ((active1 & 0x20L) != 0L)
+         if ((active1 & 0x200L) != 0L)
          {
-            jjmatchedKind = 69;
+            jjmatchedKind = 73;
             jjmatchedPos = 5;
          }
-         else if ((active1 & 0x100L) != 0L)
+         else if ((active1 & 0x1000L) != 0L)
          {
-            jjmatchedKind = 72;
+            jjmatchedKind = 76;
             jjmatchedPos = 5;
          }
-         else if ((active1 & 0x800L) != 0L)
+         else if ((active1 & 0x8000L) != 0L)
          {
-            jjmatchedKind = 75;
+            jjmatchedKind = 79;
             jjmatchedPos = 5;
          }
-         return jjMoveStringLiteralDfa6_0(active0, 0x4000000000400000L, active1, 0x1L);
+         return jjMoveStringLiteralDfa6_0(active0, 0x10800000L, active1, 0x14L);
       case 103:
-         if ((active0 & 0x100000000000L) != 0L)
+         if ((active0 & 0x1000000000000L) != 0L)
          {
-            jjmatchedKind = 44;
+            jjmatchedKind = 48;
             jjmatchedPos = 5;
          }
          break;
       case 105:
-         return jjMoveStringLiteralDfa6_0(active0, 0x800000L, active1, 0L);
+         return jjMoveStringLiteralDfa6_0(active0, 0x1100000L, active1, 0L);
       case 110:
-         return jjMoveStringLiteralDfa6_0(active0, 0x2000002000200000L, active1, 0L);
+         return jjMoveStringLiteralDfa6_0(active0, 0x20200400000L, active1, 0x2L);
       case 114:
-         if ((active0 & 0x20000000000000L) != 0L)
+         if ((active0 & 0x200000000000000L) != 0L)
          {
-            jjmatchedKind = 53;
+            jjmatchedKind = 57;
             jjmatchedPos = 5;
          }
-         return jjMoveStringLiteralDfa6_0(active0, 0x1000000L, active1, 0L);
+         return jjMoveStringLiteralDfa6_0(active0, 0x2000000L, active1, 0L);
       case 115:
-         if ((active0 & 0x10000000000L) != 0L)
+         if ((active0 & 0x100000000000L) != 0L)
          {
-            jjmatchedKind = 40;
+            jjmatchedKind = 44;
             jjmatchedPos = 5;
          }
          break;
       case 116:
-         if ((active0 & 0x100000L) != 0L)
+         if ((active0 & 0x200000L) != 0L)
          {
-            jjmatchedKind = 20;
+            jjmatchedKind = 21;
             jjmatchedPos = 5;
          }
-         else if ((active0 & 0x8000000L) != 0L)
+         else if ((active0 & 0x40000000L) != 0L)
          {
-            jjmatchedKind = 27;
+            jjmatchedKind = 30;
             jjmatchedPos = 5;
          }
-         else if ((active1 & 0x10L) != 0L)
+         else if ((active1 & 0x100L) != 0L)
          {
-            jjmatchedKind = 68;
+            jjmatchedKind = 72;
             jjmatchedPos = 5;
          }
-         else if ((active1 & 0x1000L) != 0L)
+         else if ((active1 & 0x10000L) != 0L)
          {
-            jjmatchedKind = 76;
+            jjmatchedKind = 80;
             jjmatchedPos = 5;
          }
          break;
@@ -1138,12 +1167,12 @@
          }
          break;
       case 121:
-         if ((active1 & 0x8L) != 0L)
+         if ((active1 & 0x80L) != 0L)
          {
-            jjmatchedKind = 67;
+            jjmatchedKind = 71;
             jjmatchedPos = 5;
          }
-         return jjMoveStringLiteralDfa6_0(active0, 0x100000000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa6_0(active0, 0x1000000000000000L, active1, 0L);
       default :
          break;
    }
@@ -1160,75 +1189,103 @@
    switch(curChar)
    {
       case 65:
-         return jjMoveStringLiteralDfa7_0(active0, 0x2000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa7_0(active0, 0x20000000000L, active1, 0L);
       case 66:
-         return jjMoveStringLiteralDfa7_0(active0, 0x800000L, active1, 0L);
+         return jjMoveStringLiteralDfa7_0(active0, 0x1000000L, active1, 0L);
       case 67:
-         return jjMoveStringLiteralDfa7_0(active0, 0x200000L, active1, 0L);
+         return jjMoveStringLiteralDfa7_0(active0, 0x400000L, active1, 0L);
       case 68:
-         if ((active0 & 0x400000L) != 0L)
+         if ((active0 & 0x800000L) != 0L)
          {
-            jjmatchedKind = 22;
+            jjmatchedKind = 23;
             jjmatchedPos = 6;
          }
          break;
       case 69:
-         if ((active0 & 0x8000000000L) != 0L)
+         if ((active0 & 0x80000000000L) != 0L)
          {
-            jjmatchedKind = 39;
+            jjmatchedKind = 43;
             jjmatchedPos = 6;
          }
          break;
+      case 71:
+         return jjMoveStringLiteralDfa7_0(active0, 0x200000000L, active1, 0L);
       case 75:
-         if ((active0 & 0x2000000000000000L) != 0L)
+         if ((active1 & 0x2L) != 0L)
          {
-            jjmatchedKind = 61;
+            jjmatchedKind = 65;
+            jjmatchedPos = 6;
+         }
+         break;
+      case 78:
+         if ((active0 & 0x100000L) != 0L)
+         {
+            jjmatchedKind = 20;
             jjmatchedPos = 6;
          }
          break;
       case 80:
-         return jjMoveStringLiteralDfa7_0(active0, 0x100000000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa7_0(active0, 0x1000000000000000L, active1, 0L);
       case 82:
-         return jjMoveStringLiteralDfa7_0(active0, 0x4000000000000000L, active1, 0x1L);
+         return jjMoveStringLiteralDfa7_0(active0, 0L, active1, 0x14L);
       case 84:
-         return jjMoveStringLiteralDfa7_0(active0, 0x400000000000000L, active1, 0L);
+         if ((active0 & 0x10000000L) != 0L)
+         {
+            jjmatchedKind = 28;
+            jjmatchedPos = 6;
+         }
+         return jjMoveStringLiteralDfa7_0(active0, 0x4000000000000000L, active1, 0L);
       case 85:
-         return jjMoveStringLiteralDfa7_0(active0, 0x1000000L, active1, 0L);
+         return jjMoveStringLiteralDfa7_0(active0, 0x2000000L, active1, 0L);
       case 97:
-         return jjMoveStringLiteralDfa7_0(active0, 0x2000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa7_0(active0, 0x20000000000L, active1, 0L);
       case 98:
-         return jjMoveStringLiteralDfa7_0(active0, 0x800000L, active1, 0L);
+         return jjMoveStringLiteralDfa7_0(active0, 0x1000000L, active1, 0L);
       case 99:
-         return jjMoveStringLiteralDfa7_0(active0, 0x200000L, active1, 0L);
+         return jjMoveStringLiteralDfa7_0(active0, 0x400000L, active1, 0L);
       case 100:
-         if ((active0 & 0x400000L) != 0L)
+         if ((active0 & 0x800000L) != 0L)
          {
-            jjmatchedKind = 22;
+            jjmatchedKind = 23;
             jjmatchedPos = 6;
          }
          break;
       case 101:
-         if ((active0 & 0x8000000000L) != 0L)
+         if ((active0 & 0x80000000000L) != 0L)
          {
-            jjmatchedKind = 39;
+            jjmatchedKind = 43;
             jjmatchedPos = 6;
          }
          break;
+      case 103:
+         return jjMoveStringLiteralDfa7_0(active0, 0x200000000L, active1, 0L);
       case 107:
-         if ((active0 & 0x2000000000000000L) != 0L)
+         if ((active1 & 0x2L) != 0L)
          {
-            jjmatchedKind = 61;
+            jjmatchedKind = 65;
+            jjmatchedPos = 6;
+         }
+         break;
+      case 110:
+         if ((active0 & 0x100000L) != 0L)
+         {
+            jjmatchedKind = 20;
             jjmatchedPos = 6;
          }
          break;
       case 112:
-         return jjMoveStringLiteralDfa7_0(active0, 0x100000000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa7_0(active0, 0x1000000000000000L, active1, 0L);
       case 114:
-         return jjMoveStringLiteralDfa7_0(active0, 0x4000000000000000L, active1, 0x1L);
+         return jjMoveStringLiteralDfa7_0(active0, 0L, active1, 0x14L);
       case 116:
-         return jjMoveStringLiteralDfa7_0(active0, 0x400000000000000L, active1, 0L);
+         if ((active0 & 0x10000000L) != 0L)
+         {
+            jjmatchedKind = 28;
+            jjmatchedPos = 6;
+         }
+         return jjMoveStringLiteralDfa7_0(active0, 0x4000000000000000L, active1, 0L);
       case 117:
-         return jjMoveStringLiteralDfa7_0(active0, 0x1000000L, active1, 0L);
+         return jjMoveStringLiteralDfa7_0(active0, 0x2000000L, active1, 0L);
       default :
          break;
    }
@@ -1245,76 +1302,90 @@
    switch(curChar)
    {
       case 65:
-         return jjMoveStringLiteralDfa8_0(active0, 0x4000000000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa8_0(active0, 0L, active1, 0x4L);
       case 67:
-         return jjMoveStringLiteralDfa8_0(active0, 0x400000001000000L, active1, 0L);
+         return jjMoveStringLiteralDfa8_0(active0, 0x4000000002000000L, active1, 0L);
       case 69:
-         if ((active0 & 0x800000L) != 0L)
+         if ((active0 & 0x1000000L) != 0L)
          {
-            jjmatchedKind = 23;
+            jjmatchedKind = 24;
             jjmatchedPos = 7;
          }
-         else if ((active0 & 0x100000000000000L) != 0L)
+         else if ((active0 & 0x1000000000000000L) != 0L)
          {
-            jjmatchedKind = 56;
+            jjmatchedKind = 60;
             jjmatchedPos = 7;
          }
          break;
       case 76:
-         if ((active0 & 0x2000000000L) != 0L)
+         if ((active0 & 0x20000000000L) != 0L)
          {
-            jjmatchedKind = 37;
+            jjmatchedKind = 41;
             jjmatchedPos = 7;
          }
          break;
       case 77:
-         if ((active1 & 0x1L) != 0L)
+         if ((active1 & 0x10L) != 0L)
          {
-            jjmatchedKind = 64;
+            jjmatchedKind = 68;
+            jjmatchedPos = 7;
+         }
+         break;
+      case 83:
+         if ((active0 & 0x200000000L) != 0L)
+         {
+            jjmatchedKind = 33;
             jjmatchedPos = 7;
          }
          break;
       case 84:
-         if ((active0 & 0x200000L) != 0L)
+         if ((active0 & 0x400000L) != 0L)
          {
-            jjmatchedKind = 21;
+            jjmatchedKind = 22;
             jjmatchedPos = 7;
          }
          break;
       case 97:
-         return jjMoveStringLiteralDfa8_0(active0, 0x4000000000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa8_0(active0, 0L, active1, 0x4L);
       case 99:
-         return jjMoveStringLiteralDfa8_0(active0, 0x400000001000000L, active1, 0L);
+         return jjMoveStringLiteralDfa8_0(active0, 0x4000000002000000L, active1, 0L);
       case 101:
-         if ((active0 & 0x800000L) != 0L)
+         if ((active0 & 0x1000000L) != 0L)
          {
-            jjmatchedKind = 23;
+            jjmatchedKind = 24;
             jjmatchedPos = 7;
          }
-         else if ((active0 & 0x100000000000000L) != 0L)
+         else if ((active0 & 0x1000000000000000L) != 0L)
          {
-            jjmatchedKind = 56;
+            jjmatchedKind = 60;
             jjmatchedPos = 7;
          }
          break;
       case 108:
-         if ((active0 & 0x2000000000L) != 0L)
+         if ((active0 & 0x20000000000L) != 0L)
          {
-            jjmatchedKind = 37;
+            jjmatchedKind = 41;
             jjmatchedPos = 7;
          }
          break;
       case 109:
-         if ((active1 & 0x1L) != 0L)
+         if ((active1 & 0x10L) != 0L)
          {
-            jjmatchedKind = 64;
+            jjmatchedKind = 68;
+            jjmatchedPos = 7;
+         }
+         break;
+      case 115:
+         if ((active0 & 0x200000000L) != 0L)
+         {
+            jjmatchedKind = 33;
             jjmatchedPos = 7;
          }
          break;
       case 116:
-         if ((active0 & 0x200000L) != 0L)
+         if ((active0 & 0x400000L) != 0L)
          {
-            jjmatchedKind = 21;
+            jjmatchedKind = 22;
             jjmatchedPos = 7;
          }
          break;
@@ -1334,34 +1405,34 @@
    switch(curChar)
    {
       case 72:
-         return jjMoveStringLiteralDfa9_0(active0, 0x400000000000000L);
+         return jjMoveStringLiteralDfa9_0(active0, 0x4000000000000000L, active1, 0L);
       case 76:
-         if ((active0 & 0x4000000000000000L) != 0L)
+         if ((active1 & 0x4L) != 0L)
          {
-            jjmatchedKind = 62;
+            jjmatchedKind = 66;
             jjmatchedPos = 8;
          }
          break;
       case 84:
-         if ((active0 & 0x1000000L) != 0L)
+         if ((active0 & 0x2000000L) != 0L)
          {
-            jjmatchedKind = 24;
+            jjmatchedKind = 25;
             jjmatchedPos = 8;
          }
          break;
       case 104:
-         return jjMoveStringLiteralDfa9_0(active0, 0x400000000000000L);
+         return jjMoveStringLiteralDfa9_0(active0, 0x4000000000000000L, active1, 0L);
       case 108:
-         if ((active0 & 0x4000000000000000L) != 0L)
+         if ((active1 & 0x4L) != 0L)
          {
-            jjmatchedKind = 62;
+            jjmatchedKind = 66;
             jjmatchedPos = 8;
          }
          break;
       case 116:
-         if ((active0 & 0x1000000L) != 0L)
+         if ((active0 & 0x2000000L) != 0L)
          {
-            jjmatchedKind = 24;
+            jjmatchedKind = 25;
             jjmatchedPos = 8;
          }
          break;
@@ -1370,9 +1441,9 @@
    }
    return jjMoveNfa_0(0, 8);
 }
-private int jjMoveStringLiteralDfa9_0(long old0, long active0)
+private int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1)
 {
-   if (((active0 &= old0)) == 0L)
+   if (((active0 &= old0) | (active1 &= old1)) == 0L)
       return jjMoveNfa_0(0, 8);
    try { curChar = input_stream.readChar(); }
    catch(java.io.IOException e) {
@@ -1381,9 +1452,9 @@
    switch(curChar)
    {
       case 69:
-         return jjMoveStringLiteralDfa10_0(active0, 0x400000000000000L);
+         return jjMoveStringLiteralDfa10_0(active0, 0x4000000000000000L);
       case 101:
-         return jjMoveStringLiteralDfa10_0(active0, 0x400000000000000L);
+         return jjMoveStringLiteralDfa10_0(active0, 0x4000000000000000L);
       default :
          break;
    }
@@ -1400,16 +1471,16 @@
    switch(curChar)
    {
       case 83:
-         if ((active0 & 0x400000000000000L) != 0L)
+         if ((active0 & 0x4000000000000000L) != 0L)
          {
-            jjmatchedKind = 58;
+            jjmatchedKind = 62;
             jjmatchedPos = 10;
          }
          break;
       case 115:
-         if ((active0 & 0x400000000000000L) != 0L)
+         if ((active0 & 0x4000000000000000L) != 0L)
          {
-            jjmatchedKind = 58;
+            jjmatchedKind = 62;
             jjmatchedPos = 10;
          }
          break;
@@ -1482,8 +1553,8 @@
                case 0:
                   if ((0x3ff000000000000L & l) != 0L)
                   {
-                     if (kind > 80)
-                        kind = 80;
+                     if (kind > 84)
+                        kind = 84;
                      jjCheckNAddStates(0, 6);
                   }
                   else if (curChar == 45)
@@ -1607,8 +1678,8 @@
                   jjCheckNAddTwoStates(21, 22);
                   break;
                case 24:
-                  if ((0x8400000000L & l) != 0L && kind > 92)
-                     kind = 92;
+                  if ((0x8400000000L & l) != 0L && kind > 96)
+                     kind = 96;
                   break;
                case 25:
                   if (curChar == 39)
@@ -1623,8 +1694,8 @@
                      jjCheckNAddStates(26, 28);
                   break;
                case 29:
-                  if (curChar == 39 && kind > 93)
-                     kind = 93;
+                  if (curChar == 39 && kind > 97)
+                     kind = 97;
                   break;
                case 30:
                   if (curChar == 34)
@@ -1639,8 +1710,8 @@
                      jjCheckNAddStates(23, 25);
                   break;
                case 34:
-                  if (curChar == 34 && kind > 94)
-                     kind = 94;
+                  if (curChar == 34 && kind > 98)
+                     kind = 98;
                   break;
                case 35:
                   if (curChar == 39)
@@ -1664,8 +1735,8 @@
                      jjAddStates(33, 34);
                   break;
                case 42:
-                  if (curChar == 39 && kind > 95)
-                     kind = 95;
+                  if (curChar == 39 && kind > 99)
+                     kind = 99;
                   break;
                case 43:
                   if (curChar == 39)
@@ -1701,8 +1772,8 @@
                      jjAddStates(39, 40);
                   break;
                case 53:
-                  if (curChar == 34 && kind > 96)
-                     kind = 96;
+                  if (curChar == 34 && kind > 100)
+                     kind = 100;
                   break;
                case 54:
                   if (curChar == 34)
@@ -1737,8 +1808,8 @@
                      jjCheckNAddStates(17, 19);
                   break;
                case 62:
-                  if (curChar == 41 && kind > 99)
-                     kind = 99;
+                  if (curChar == 41 && kind > 103)
+                     kind = 103;
                   break;
                case 63:
                   if (curChar == 10)
@@ -1821,15 +1892,15 @@
                case 84:
                   if ((0x3ff000000000000L & l) == 0L)
                      break;
-                  if (kind > 80)
-                     kind = 80;
+                  if (kind > 84)
+                     kind = 84;
                   jjCheckNAddStates(0, 6);
                   break;
                case 85:
                   if ((0x3ff000000000000L & l) == 0L)
                      break;
-                  if (kind > 80)
-                     kind = 80;
+                  if (kind > 84)
+                     kind = 84;
                   jjCheckNAdd(85);
                   break;
                case 86:
@@ -1839,15 +1910,15 @@
                case 87:
                   if (curChar != 46)
                      break;
-                  if (kind > 81)
-                     kind = 81;
+                  if (kind > 85)
+                     kind = 85;
                   jjCheckNAdd(88);
                   break;
                case 88:
                   if ((0x3ff000000000000L & l) == 0L)
                      break;
-                  if (kind > 81)
-                     kind = 81;
+                  if (kind > 85)
+                     kind = 85;
                   jjCheckNAdd(88);
                   break;
                case 89:
@@ -1869,8 +1940,8 @@
                case 94:
                   if ((0x3ff000000000000L & l) == 0L)
                      break;
-                  if (kind > 82)
-                     kind = 82;
+                  if (kind > 86)
+                     kind = 86;
                   jjCheckNAdd(94);
                   break;
                case 95:
@@ -1884,8 +1955,8 @@
                case 98:
                   if ((0x3ff000000000000L & l) == 0L)
                      break;
-                  if (kind > 82)
-                     kind = 82;
+                  if (kind > 86)
+                     kind = 86;
                   jjCheckNAdd(98);
                   break;
                case 99:
@@ -1895,8 +1966,8 @@
                case 100:
                   if ((0x3ff000000000000L & l) == 0L)
                      break;
-                  if (kind > 81)
-                     kind = 81;
+                  if (kind > 85)
+                     kind = 85;
                   jjCheckNAdd(100);
                   break;
                case 101:
@@ -1910,8 +1981,8 @@
                case 104:
                   if ((0x3ff000000000000L & l) == 0L)
                      break;
-                  if (kind > 82)
-                     kind = 82;
+                  if (kind > 86)
+                     kind = 86;
                   jjCheckNAdd(104);
                   break;
                case 105:
@@ -1921,8 +1992,8 @@
                case 106:
                   if ((0x3ff000000000000L & l) == 0L)
                      break;
-                  if (kind > 83)
-                     kind = 83;
+                  if (kind > 87)
+                     kind = 87;
                   jjCheckNAdd(106);
                   break;
                case 107:
@@ -1932,15 +2003,15 @@
                case 108:
                   if (curChar != 46)
                      break;
-                  if (kind > 84)
-                     kind = 84;
+                  if (kind > 88)
+                     kind = 88;
                   jjCheckNAdd(109);
                   break;
                case 109:
                   if ((0x3ff000000000000L & l) == 0L)
                      break;
-                  if (kind > 84)
-                     kind = 84;
+                  if (kind > 88)
+                     kind = 88;
                   jjCheckNAdd(109);
                   break;
                case 110:
@@ -1950,8 +2021,8 @@
                case 111:
                   if ((0x3ff000000000000L & l) == 0L)
                      break;
-                  if (kind > 84)
-                     kind = 84;
+                  if (kind > 88)
+                     kind = 88;
                   jjCheckNAdd(111);
                   break;
                case 112:
@@ -1969,8 +2040,8 @@
                case 116:
                   if ((0x3ff000000000000L & l) == 0L)
                      break;
-                  if (kind > 85)
-                     kind = 85;
+                  if (kind > 89)
+                     kind = 89;
                   jjCheckNAdd(116);
                   break;
                case 117:
@@ -1996,8 +2067,8 @@
                case 123:
                   if ((0x3ff000000000000L & l) == 0L)
                      break;
-                  if (kind > 85)
-                     kind = 85;
+                  if (kind > 89)
+                     kind = 89;
                   jjCheckNAdd(123);
                   break;
                case 124:
@@ -2011,8 +2082,8 @@
                case 127:
                   if ((0x3ff000000000000L & l) == 0L)
                      break;
-                  if (kind > 85)
-                     kind = 85;
+                  if (kind > 89)
+                     kind = 89;
                   jjCheckNAdd(127);
                   break;
                case 128:
@@ -2022,8 +2093,8 @@
                case 129:
                   if ((0x3ff000000000000L & l) == 0L)
                      break;
-                  if (kind > 86)
-                     kind = 86;
+                  if (kind > 90)
+                     kind = 90;
                   jjCheckNAdd(129);
                   break;
                case 130:
@@ -2033,15 +2104,15 @@
                case 131:
                   if (curChar != 46)
                      break;
-                  if (kind > 87)
-                     kind = 87;
+                  if (kind > 91)
+                     kind = 91;
                   jjCheckNAdd(132);
                   break;
                case 132:
                   if ((0x3ff000000000000L & l) == 0L)
                      break;
-                  if (kind > 87)
-                     kind = 87;
+                  if (kind > 91)
+                     kind = 91;
                   jjCheckNAdd(132);
                   break;
                case 133:
@@ -2051,8 +2122,8 @@
                case 134:
                   if ((0x3ff000000000000L & l) == 0L)
                      break;
-                  if (kind > 87)
-                     kind = 87;
+                  if (kind > 91)
+                     kind = 91;
                   jjCheckNAdd(134);
                   break;
                case 135:
@@ -2070,8 +2141,8 @@
                case 139:
                   if ((0x3ff000000000000L & l) == 0L)
                      break;
-                  if (kind > 88)
-                     kind = 88;
+                  if (kind > 92)
+                     kind = 92;
                   jjCheckNAdd(139);
                   break;
                case 140:
@@ -2097,8 +2168,8 @@
                case 146:
                   if ((0x3ff000000000000L & l) == 0L)
                      break;
-                  if (kind > 88)
-                     kind = 88;
+                  if (kind > 92)
+                     kind = 92;
                   jjCheckNAdd(146);
                   break;
                case 147:
@@ -2112,8 +2183,8 @@
                case 150:
                   if ((0x3ff000000000000L & l) == 0L)
                      break;
-                  if (kind > 88)
-                     kind = 88;
+                  if (kind > 92)
+                     kind = 92;
                   jjCheckNAdd(150);
                   break;
                default : break;
@@ -2206,8 +2277,8 @@
                      jjstateSet[jjnewStateCnt++] = 24;
                   break;
                case 24:
-                  if ((0x14404410000000L & l) != 0L && kind > 92)
-                     kind = 92;
+                  if ((0x14404410000000L & l) != 0L && kind > 96)
+                     kind = 96;
                   break;
                case 26:
                   if ((0xffffffffefffffffL & l) != 0L)
@@ -2268,8 +2339,8 @@
                   jjCheckNAddStates(47, 52);
                   break;
                case 70:
-                  if (curChar == 93 && kind > 104)
-                     kind = 104;
+                  if (curChar == 93 && kind > 108)
+                     kind = 108;
                   break;
                case 73:
                   if ((0x7fffffe07fffffeL & l) != 0L)
@@ -2348,7 +2419,7 @@
       }
       else
       {
-         int hiByte = (curChar >> 8);
+         int hiByte = (int)(curChar >> 8);
          int i1 = hiByte >> 6;
          long l1 = 1L << (hiByte & 077);
          int i2 = (curChar & 0xff) >> 6;
@@ -2520,7 +2591,7 @@
    {
       case 0:
          return ((jjbitVec2[i2] & l2) != 0L);
-      default :
+      default : 
          if ((jjbitVec0[i1] & l1) != 0L)
             return true;
          return false;
@@ -2544,7 +2615,7 @@
          return ((jjbitVec0[i2] & l2) != 0L);
       case 255:
          return ((jjbitVec9[i2] & l2) != 0L);
-      default :
+      default : 
          if ((jjbitVec3[i1] & l1) != 0L)
             return true;
          return false;
@@ -2568,7 +2639,7 @@
          return ((jjbitVec0[i2] & l2) != 0L);
       case 255:
          return ((jjbitVec9[i2] & l2) != 0L);
-      default :
+      default : 
          if ((jjbitVec3[i1] & l1) != 0L)
             return true;
          return false;
@@ -2584,17 +2655,18 @@
 null, null, null, null, null, null, null, null, null, null, null, null, null, null, 
 null, null, null, null, null, null, null, null, null, null, null, null, null, null, 
 null, null, null, null, null, null, null, null, null, null, null, null, null, null, 
-"\50", "\51", null, "\173", "\175", "\133", "\135", null, "\73", "\54", "\56", "\75", 
-"\41\75", "\76", "\74", "\74\75", "\76\75", "\41", "\176", "\72", "\174\174", "\46\46", 
-"\53", "\55", "\52", "\57", "\136\136", "\100", "\72\75", "\174", "\136", "\55\76", 
-"\74\55", "\77", null, null, null, null, null, null, null, };
+null, null, null, null, "\50", "\51", null, "\173", "\175", "\133", "\135", null, 
+"\73", "\54", "\56", "\75", "\41\75", "\76", "\74", "\74\75", "\76\75", "\41", 
+"\176", "\72", "\174\174", "\46\46", "\53", "\55", "\52", "\57", "\136\136", "\100", 
+"\72\75", "\174", "\136", "\55\76", "\74\55", "\77", "\156\165\154\154", null, null, 
+null, null, null, null, null, };
 
 /** Lexer state names. */
 public static final String[] lexStateNames = {
-   "DEFAULT",
+   "DEFAULT", 
 };
 static final long[] jjtoToken = {
-   0xfffffffffffe7f01L, 0xfffffffff1ff7fffL, 0x7L, 
+   0xfffffffffffe7f01L, 0xffffffff1ff7ffffL, 0xffL, 
 };
 static final long[] jjtoSkip = {
    0xbeL, 0x0L, 0x0L, 
@@ -2691,13 +2763,13 @@
 
   EOFLoop :
   for (;;)
-  {
-   try
-   {
+  {   
+   try   
+   {     
       curChar = input_stream.BeginToken();
-   }
+   }     
    catch(java.io.IOException e)
-   {
+   {        
       jjmatchedKind = 0;
       matchedToken = jjFillToken();
       matchedToken.specialToken = specialToken;
Index: src/com/hp/hpl/jena/sparql/lang/arq/JavaCharStream.java
===================================================================
--- src/com/hp/hpl/jena/sparql/lang/arq/JavaCharStream.java	(revision 6629)
+++ src/com/hp/hpl/jena/sparql/lang/arq/JavaCharStream.java	(working copy)
@@ -179,7 +179,7 @@
 
 /** @return starting character for token. */
   public char BeginToken() throws java.io.IOException
-  {
+  {     
      if (inBuf > 0)
      {
         --inBuf;
@@ -195,7 +195,7 @@
      bufpos = -1;
 
      return readChar();
-  }
+  }     
 
   protected void AdjustBuffSize()
   {
@@ -350,18 +350,16 @@
      }
   }
 
-  @Deprecated
   /**
-   * @deprecated
+   * @deprecated 
    * @see #getEndColumn
    */
   public int getColumn() {
      return bufcolumn[bufpos];
   }
 
-  @Deprecated
   /**
-   * @deprecated
+   * @deprecated 
    * @see #getEndLine
    */
   public int getLine() {
@@ -597,7 +595,7 @@
         bufcolumn[j] = newCol + columnDiff;
         columnDiff = nextColDiff;
         i++;
-     }
+     } 
 
      if (i < len)
      {
@@ -618,4 +616,4 @@
   }
 
 }
-/* JavaCC - OriginalChecksum=761722f90171cbdd0b94b135f631a609 (do not edit this line) */
+/* JavaCC - OriginalChecksum=524563a88846e0cab20df7c24c0e2f75 (do not edit this line) */
Index: src/com/hp/hpl/jena/sparql/algebra/opt/TransformFilterImprove.java
===================================================================
--- src/com/hp/hpl/jena/sparql/algebra/opt/TransformFilterImprove.java	(revision 6629)
+++ src/com/hp/hpl/jena/sparql/algebra/opt/TransformFilterImprove.java	(working copy)
@@ -9,7 +9,17 @@
 import com.hp.hpl.jena.sparql.algebra.Op;
 import com.hp.hpl.jena.sparql.algebra.TransformCopy;
 import com.hp.hpl.jena.sparql.algebra.op.OpFilter;
+import com.hp.hpl.jena.sparql.expr.E_LogicalAnd;
+import com.hp.hpl.jena.sparql.expr.E_LogicalNot;
+import com.hp.hpl.jena.sparql.expr.E_LogicalOr;
+import com.hp.hpl.jena.sparql.expr.Expr;
+import com.hp.hpl.jena.sparql.expr.ExprFunction;
+import com.hp.hpl.jena.sparql.expr.ExprFunction1;
+import com.hp.hpl.jena.sparql.expr.ExprFunction2;
 import com.hp.hpl.jena.sparql.expr.ExprList;
+import com.hp.hpl.jena.sparql.expr.ExprVar;
+import com.hp.hpl.jena.sparql.expr.ExprVisitor;
+import com.hp.hpl.jena.sparql.expr.NodeValue;
 
 /** Improvements to filters that do not chnage the rest of the tree 
  * (so, fo rexample, not filter replacement or equality/assignment
@@ -32,11 +42,309 @@
     @Override
     public Op transform(OpFilter opFilter, Op subOp)
     {
-        ExprList exprList = opFilter.getExprs() ;
+    	Expr single = flattenConjunctions(opFilter.getExprs());
+		DeMorganLawApplyer deMorgan = new DeMorganLawApplyer();
+		single.visit(deMorgan);
+		DistributiveLawApplyer dist = new DistributiveLawApplyer();
+		single.visit(dist);
+		
+		ExprList exprList = new ExprList();
+		exprList.add(single);
         exprList = ExprList.splitConjunction(exprList) ;
         return OpFilter.filter(exprList, subOp) ;
     }
 
+	public static Expr flattenConjunctions(ExprList exprs) {
+		if (exprs.size() == 0) return null;
+		
+		Expr prev = null;
+		for (Expr e : exprs) {
+			if (prev == null)
+				prev = e;
+			else {
+				prev = new E_LogicalAnd(prev, e);
+			}
+		}
+		return prev;
+	}
+
+    /**
+     * Visitor for a filter-expression. Visits every expression-node of the expression-tree
+     * and applies the Distributive-law: a || (b && c) will become (a || b) && (a || c)
+     * 
+     * @author Herwig Leimer
+     *
+     */
+    static class DistributiveLawApplyer implements ExprVisitor 
+    {
+    	private Expr resultExpr;
+    	
+    	/**
+    	 * Constructor
+    	 */
+    	public DistributiveLawApplyer()
+    	{		
+    	}
+
+    	public void finishVisit() 
+    	{
+    	}
+
+    	public void startVisit() 
+    	{
+    	}
+
+    	public void visit(ExprFunction curExpr) 
+    	{
+    		Expr subExpr, leftExpr, rightExpr;
+    		Expr leftLeftExpr, rightLeftExpr, leftRightExpr, rightRightExpr;
+    		Expr newAndExpr, newOrExpr1, newOrExpr2;
+    		
+    		if (curExpr instanceof E_LogicalNot)
+    		{
+    			subExpr = curExpr;
+    			// step down
+    			this.resultExpr = curExpr;
+    			((ExprFunction1) subExpr).getArg().visit(this);
+    			this.resultExpr = new E_LogicalNot(this.resultExpr);
+    			
+    		}else if (curExpr instanceof ExprFunction2)
+    		{
+    			if (curExpr instanceof E_LogicalOr || curExpr instanceof E_LogicalAnd)
+    			{
+    				// step down
+    				leftExpr = ((ExprFunction2)curExpr).getArg1();
+    				leftExpr.visit(this);
+    				leftExpr = this.resultExpr;
+
+    				// step down
+    				rightExpr = ((ExprFunction2)curExpr).getArg2();
+    				rightExpr.visit(this);
+    				rightExpr = this.resultExpr;
+    				
+    				if (curExpr instanceof E_LogicalOr)
+    				{
+    					if (!(leftExpr instanceof E_LogicalAnd) && !(rightExpr instanceof E_LogicalAnd))
+    					{
+    						// no distributive law - normal or
+    						this.resultExpr = new E_LogicalOr(leftExpr, rightExpr);
+    					}else
+    					{
+    						// criterion for distributive law - first OR, then AND
+    						
+    						if (leftExpr instanceof E_LogicalAnd)
+    						{
+    							leftLeftExpr = ((E_LogicalAnd)leftExpr).getArg1();
+    							rightLeftExpr = ((E_LogicalAnd)leftExpr).getArg2();
+    							
+    							// OR AND will become to AND OR OR
+    							newOrExpr1 = new E_LogicalOr(leftLeftExpr, rightExpr);
+    							newOrExpr2 = new E_LogicalOr(rightLeftExpr, rightExpr);
+    							newAndExpr = new E_LogicalAnd(newOrExpr1, newOrExpr2);
+    							
+    							this.resultExpr = newAndExpr;
+    							// apply for subexpression again
+    							newAndExpr.visit(this);
+    						}
+    						
+    						if (rightExpr instanceof E_LogicalAnd)
+    						{
+    							leftRightExpr = ((E_LogicalAnd)rightExpr).getArg1();
+    							rightRightExpr = ((E_LogicalAnd)rightExpr).getArg2();
+    						
+    							// OR AND will become to AND OR OR
+    							newOrExpr1 = new E_LogicalOr(leftExpr, leftRightExpr);
+    							newOrExpr2 = new E_LogicalOr(leftExpr, rightRightExpr);
+    							newAndExpr = new E_LogicalAnd(newOrExpr1, newOrExpr2);
+    						
+    							this.resultExpr = newAndExpr;
+    							// apply for subexpression again
+    							newAndExpr.visit(this);
+    						}
+    					}					
+    				}else
+    				{
+    					// E_LogicalAnd
+    					this.resultExpr = new E_LogicalAnd(leftExpr, rightExpr);
+    				}				
+    			}else
+    			{
+    				this.resultExpr = curExpr;
+    			}
+    		}else
+    		{
+    			// TODO: what is with ExpressionFunctionN
+    		}
+    	}
+
+    	public void visit(NodeValue nv) 
+    	{
+    		this.resultExpr = nv;
+    	}
+
+    	public void visit(ExprVar nv) 
+    	{
+    		this.resultExpr = nv;
+    	}
+
+    	
+    	public Expr result()
+        { 
+            return resultExpr; 
+        }
+    }
+    
+	/**
+	 * Visitor for a filter-expression. Visits every expression-node of the expression-tree
+	 * and applies the DeMorgan-law: !(a || b) will become !a && !b
+	 * 
+	 * @author Herwig Leimer
+	 *
+	 */
+    static class DeMorganLawApplyer implements ExprVisitor 
+    {
+    	private Expr resultExpr;
+    	
+    	/**
+    	 * Constructor
+    	 */
+    	public DeMorganLawApplyer()
+    	{		
+    	}
+
+    	public void finishVisit() 
+    	{
+    	}
+
+    	public void startVisit() 
+    	{
+    	}
+    	
+    	public void visit(ExprFunction curExpr) 
+    	{
+    		Expr subExpr, leftExpr, rightExpr;
+    		Expr newAndExpr, newOrExpr;
+    		
+    		if (curExpr instanceof ExprFunction1)
+    		{
+    			subExpr = ((ExprFunction1)curExpr).getArg();
+    			
+    			if (curExpr instanceof E_LogicalNot)
+    			{
+    				// !!a ==> a
+    				if (subExpr instanceof E_LogicalNot) {
+    					this.resultExpr = ((ExprFunction1) subExpr).getArg();
+    				}
+    				
+    				// apply DeMorgan
+    				// !(a || b) ==> !a && !b
+       			    // AndyL: don't change !(a && b) to !a || !b (no benefit!) 
+    				else if (subExpr instanceof E_LogicalOr )
+    				{
+    					// step down
+    					leftExpr = ((ExprFunction2)subExpr).getArg1();
+    					leftExpr.visit(this);
+    					leftExpr = this.resultExpr;
+    	
+    					// step down
+    					rightExpr = ((ExprFunction2)subExpr).getArg2();
+    					rightExpr.visit(this);
+    					rightExpr = this.resultExpr;
+    					
+    					
+    					if (!(leftExpr instanceof E_LogicalNot))
+    					{
+    						// add not
+    						leftExpr = new E_LogicalNot(leftExpr);	
+    					}else
+    					{
+    						// remove not
+    						leftExpr = ((E_LogicalNot)leftExpr).getArg();
+    					}
+    					
+    					if (!(rightExpr instanceof E_LogicalNot))
+    					{
+    						// add not
+    						rightExpr = new E_LogicalNot(rightExpr);
+    					}else
+    					{
+    						// remove not
+    						rightExpr = ((E_LogicalNot)rightExpr).getArg();
+    					}
+    					
+//    					// change operator
+//    					if (subExpr instanceof E_LogicalAnd)
+//    					{
+//    						newOrExpr = new E_LogicalOr(leftExpr, rightExpr);
+//    						this.resultExpr = newOrExpr;
+//    						
+//    					}else if (subExpr instanceof E_LogicalOr)
+//    					{
+    						newAndExpr = new E_LogicalAnd(leftExpr, rightExpr);
+    						this.resultExpr = newAndExpr;
+//    					}
+    				
+    				}else
+    				{
+    					this.resultExpr = curExpr;
+    				}
+    			}else
+    			{
+    				// step down
+    				subExpr.visit(this);	
+    				this.resultExpr = curExpr;
+    			}
+    						
+    		}else if (curExpr instanceof ExprFunction2)
+    		{
+    			if (curExpr instanceof E_LogicalOr || curExpr instanceof E_LogicalAnd)
+    			{
+    				// step down
+    				leftExpr = ((ExprFunction2)curExpr).getArg1();
+    				leftExpr.visit(this);
+    				leftExpr = this.resultExpr;
+
+    				// step down
+    				rightExpr = ((ExprFunction2)curExpr).getArg2();
+    				rightExpr.visit(this);
+    				rightExpr = this.resultExpr;
+    				
+    				// create new And/Or with resultExpr
+    				if (curExpr instanceof E_LogicalOr)
+    				{
+    					this.resultExpr = new E_LogicalOr(leftExpr, rightExpr);
+    				}else if (curExpr instanceof E_LogicalAnd)
+    				{
+    					this.resultExpr = new E_LogicalAnd(leftExpr, rightExpr);
+    				}
+    							
+    			}else
+    			{
+    				this.resultExpr = curExpr;
+    			}
+    		}else
+    		{
+    			// ExpressionFunction like E_Regex or ExpressionFunctionN
+    			this.resultExpr = curExpr;
+    		}
+    	}
+
+    	public void visit(NodeValue nv) 
+    	{
+    		this.resultExpr = nv;
+    	}
+
+    	public void visit(ExprVar nv) 
+    	{
+    		this.resultExpr = nv;
+    	}
+
+    	
+    	public Expr result()
+        { 
+            return resultExpr; 
+        }
+    }
 }
     
 /*
Index: src-test/com/hp/hpl/jena/sparql/junit/TestFilterPushDown.java
===================================================================
--- src-test/com/hp/hpl/jena/sparql/junit/TestFilterPushDown.java	(revision 0)
+++ src-test/com/hp/hpl/jena/sparql/junit/TestFilterPushDown.java	(revision 0)
@@ -0,0 +1,148 @@
+/**
+ * 
+ */
+package com.hp.hpl.jena.sparql.junit;
+
+import junit.framework.TestCase;
+
+import com.hp.hpl.jena.query.ARQ;
+import com.hp.hpl.jena.query.Query;
+import com.hp.hpl.jena.query.QueryFactory;
+import com.hp.hpl.jena.query.Syntax;
+import com.hp.hpl.jena.sparql.algebra.Algebra;
+import com.hp.hpl.jena.sparql.algebra.AlgebraGenerator;
+import com.hp.hpl.jena.sparql.algebra.Op;
+
+/**
+ * @author Andreas Langegger <dorgon@users.sf.net>
+ *
+ * TODO: very bad quick testing here based on string comparison, should be improved, likely to fail after changes to the query engine 
+ */
+public class TestFilterPushDown extends TestCase {
+
+	static {
+		ARQ.setStrictMode();
+		ARQ.getContext().set(ARQ.filterPlacement, true);
+	}
+	
+	public void testFilterMerge() {
+		String qry = 
+			"PREFIX  :   <http://example.com/>\n" +
+			"SELECT  * \n" +
+			"WHERE { \n" +
+			"  { ?a ?c [] }\n" +
+			"  { ?a ?b ?d . FILTER (bound(?a)) }\n" +
+			"  FILTER ( ?e = 3 ) FILTER (?a = 1) FILTER (?b = 2 && ?c = ?d)\n" +
+			"}";
+		Op op = optimized(qry);
+		equalsIgnoreWS(
+				"(tolist " +
+				"  (filter (exprlist (= ?e 3) (= ?c ?d)) " +
+				"    (sequence " +
+				"      (assign ((?a 1)) " +
+				"        (bgp (triple 1 ?c ??0))) " +
+				"      (filter (bound ?a) " +
+				"        (assign ((?a 1) (?b 2))" +
+				"          (bgp (triple 1 2 ?d)))))))", op.toString());
+	}
+	
+	public void testFilterPushDownJoin() {
+		String qry = 
+			"PREFIX  :   <http://example.com/>\n" +
+			"SELECT  * \n" +
+			"WHERE { \n" +
+			"  { ?a ?c [] }\n" +
+			"  { ?a ?b ?d }\n" +
+			"  FILTER ( ?a = 1 && ?b = 2 && ?c = ?d && bound(?a)) }\n";
+		Op op = optimized(qry);
+		equalsIgnoreWS(
+				"(tolist " +
+				"  (filter (= ?c ?d) " +
+				"    (sequence " +
+				"      (filter (bound ?a) " +
+				"        (assign ((?a 1)) " +
+				"          (bgp (triple 1 ?c ??0)))) " +
+				"      (filter (bound ?a) " +
+				"        (assign ((?a 1) (?b 2)) " +
+				"          (bgp (triple 1 2 ?d)))))))", op.toString());
+	}
+	
+	public void testFilterPushDownUnion() {
+		String qry = 
+			"PREFIX  :   <http://example.com/>\n" +
+			"SELECT  *\n" +
+			"WHERE { \n" +
+			"  { ?a ?c [] }\n" +
+			"   UNION \n" +
+			"  { ?a ?b ?d }\n" +
+			"  FILTER ( ?a = 1 && ?b = 2 && ?c = ?d && bound(?a)) }\n";
+		Op op = optimized(qry);
+		equalsIgnoreWS(
+				"(tolist" +
+				"  (filter (= ?c ?d)" +
+				"    (union" +
+				"      (filter (bound ?a)" +
+				"        (assign ((?a 1))" +
+				"          (bgp (triple 1 ?c ??0))))" +
+				"      (filter (bound ?a)" +
+				"        (assign ((?a 1) (?b 2))" +
+				"          (bgp (triple 1 2 ?d)))))))", op.toString());
+	}
+	
+	public void testFilterPushDownLeftJoin() {
+		String qry = 
+			"PREFIX  :   <http://example.com/>\n" +
+			"SELECT  *\n" +
+			"WHERE { \n" +
+			"  ?a ?c [] .\n" +
+			"  OPTIONAL { ?a ?b ?d }\n" +
+			"  FILTER ( ?a = 1 && ?b = 2 && ?c = ?d && bound(?a)) }\n";
+		Op op = optimized(qry);
+		equalsIgnoreWS(
+				"(tolist " +
+				"  (filter (exprlist (= ?b 2) (= ?c ?d)) " +
+				"    (conditional " +
+				"      (filter (bound ?a) " +
+				"        (assign ((?a 1)) " +
+				"          (bgp (triple 1 ?c ??0)))) " +
+				"          (bgp (triple ?a ?b ?d)))))", op.toString());
+	}
+
+	public void testAnotherFilterPushDown() {
+		String qry =
+			"PREFIX  :   <http://example.com/>\n" +
+			"SELECT * WHERE {\n" +
+			"  { ?s1 a :A }\n" +
+			"  {\n" +
+			"    {?s1 :p1 ?p1} \n" +
+			"    {?s2 a :B } \n" +
+			"  }" +
+			"  { ?s2 :p2 ?p2 } \n" +
+			"  FILTER (?p1 = ?p2 && bound(?p2) && ?p1 = :Foo) \n" +
+			"}";
+		Op op = optimized(qry);
+		equalsIgnoreWS(
+				"(tolist " +
+				"  (filter (= ?p1 ?p2) " +
+				"    (sequence " +
+				"      (bgp (triple ?s1 <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://example.com/A>)) " +
+				"      (filter (= ?p1 <http://example.com/Foo>) " +
+				"        (sequence " +
+				"          (bgp (triple ?s1 <http://example.com/p1> ?p1)) " +
+				"          (bgp (triple ?s2 <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://example.com/B>)))) " +
+				"      (filter (bound ?p2) " +
+				"        (bgp (triple ?s2 <http://example.com/p2> ?p2))))))", op.toString());
+	}
+	
+	private static Op optimized(String qry) {
+		Query q = QueryFactory.create(qry, Syntax.syntaxARQ);
+		Op op = new AlgebraGenerator().compile(q);
+		return Algebra.optimize(op);
+	}
+	
+	private static void equalsIgnoreWS(String expected, String actual) {
+		expected = expected.trim().replaceAll("\\s+", " ");
+		actual = actual.trim().replaceAll("\\s+", " ");
+		assertEquals(expected, actual);
+	}
+}
Index: src/com/hp/hpl/jena/sparql/lang/arq/TokenMgrError.java
===================================================================
--- src/com/hp/hpl/jena/sparql/lang/arq/TokenMgrError.java	(revision 6629)
+++ src/com/hp/hpl/jena/sparql/lang/arq/TokenMgrError.java	(working copy)
@@ -8,7 +8,6 @@
 package com.hp.hpl.jena.sparql.lang.arq ;
 
 /** Token Manager Error. */
-@SuppressWarnings("serial")
 public class TokenMgrError extends Error
 {
 
@@ -94,7 +93,7 @@
    /**
     * Returns a detailed message for the Error when it is thrown by the
     * token manager to indicate a lexical error.
-    * Parameters :
+    * Parameters : 
     *    EOFSeen     : indicates if EOF caused the lexical error
     *    curLexState : lexical state in which this error occurred
     *    errorLine   : line number when the error occurred
@@ -114,13 +113,13 @@
    /**
     * You can also modify the body of this method to customize your error messages.
     * For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not
-    * of end-users concern, so you can return something like :
+    * of end-users concern, so you can return something like : 
     *
     *     "Internal Error : Please file a bug report .... "
     *
     * from this method for such cases in the release version of your parser.
     */
-   @Override public String getMessage() {
+   public String getMessage() {
       return super.getMessage();
    }
 
@@ -143,4 +142,4 @@
       this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason);
    }
 }
-/* JavaCC - OriginalChecksum=5e5af44f311c5ef71e543d36a43be8a2 (do not edit this line) */
+/* JavaCC - OriginalChecksum=ebce1db65dd6857168e55e79bfc7cfa9 (do not edit this line) */
Index: src/com/hp/hpl/jena/sparql/engine/main/iterator/QueryIterJoinBase.java
===================================================================
--- src/com/hp/hpl/jena/sparql/engine/main/iterator/QueryIterJoinBase.java	(revision 6629)
+++ src/com/hp/hpl/jena/sparql/engine/main/iterator/QueryIterJoinBase.java	(working copy)
@@ -115,11 +115,11 @@
     {
         if ( !getLeft().hasNext() )
             return null ;
-        if ( exprs != null )
-            throw new ARQInternalErrorException("QueryIterJoinBase: expression not empty for equiJoin") ;
+//        if ( exprs != null )
+//            throw new ARQInternalErrorException("QueryIterJoinBase: expression not empty for equiJoin") ;
         
         Binding b =  getLeft().nextBinding() ;
-        QueryIterator x = tableRight.matchRightLeft(b, false, null, getExecContext()) ;
+        QueryIterator x = tableRight.matchRightLeft(b, false, exprs, getExecContext()) ;
         return x ;
     }
 }
Index: src-test/com/hp/hpl/jena/sparql/junit/TestQueryExtensions.java
===================================================================
--- src-test/com/hp/hpl/jena/sparql/junit/TestQueryExtensions.java	(revision 0)
+++ src-test/com/hp/hpl/jena/sparql/junit/TestQueryExtensions.java	(revision 0)
@@ -0,0 +1,135 @@
+package com.hp.hpl.jena.sparql.junit;
+
+import java.io.StringReader;
+
+import junit.framework.TestCase;
+
+import com.hp.hpl.jena.query.Dataset;
+import com.hp.hpl.jena.query.Query;
+import com.hp.hpl.jena.query.QueryExecution;
+import com.hp.hpl.jena.query.QueryExecutionFactory;
+import com.hp.hpl.jena.query.QueryFactory;
+import com.hp.hpl.jena.query.QuerySolutionMap;
+import com.hp.hpl.jena.query.ResultSet;
+import com.hp.hpl.jena.query.ResultSetFormatter;
+import com.hp.hpl.jena.query.Syntax;
+import com.hp.hpl.jena.rdf.model.Model;
+import com.hp.hpl.jena.rdf.model.ModelFactory;
+import com.hp.hpl.jena.sparql.algebra.table.TableN;
+import com.hp.hpl.jena.sparql.core.DatasetImpl;
+import com.hp.hpl.jena.sparql.vocabulary.FOAF;
+import com.hp.hpl.jena.util.FileManager;
+import com.hp.hpl.jena.vocabulary.RDF;
+import com.hp.hpl.jena.vocabulary.XSD;
+
+public class TestQueryExtensions extends TestCase {
+	
+	public void testInitialBindingsSyntax() {
+		String qry = 
+			"PREFIX  ex:   <http://example.com/>\n" +
+			"PREFIX  foaf: <" + FOAF.getURI() + ">\n" +
+			"PREFIX  xsd:  <" + XSD.getURI() + ">\n" +
+			"\n" +
+			"SELECT  *\n" +
+			"WHERE\n" +
+			"  { ?p foaf:knows ?knows .\n" +
+			"    ?p foaf:name ?name .\n" +
+			"    ?p ex:age ?age\n" +
+			"  }\n" +
+			"BINDINGS ?name ?age {\n" +
+			"  \"Tom\" \"30\"^^xsd:int .\n" +
+			"  \"Claudia\" null .\n" +
+			"  null \"50\"^^xsd:int .\n" +
+			"}\n" +
+			"ORDER BY ?age\n";
+		
+		Query q = QueryFactory.create(qry, Syntax.syntaxARQ);
+		assertEquals(qry, q.toString());
+	}
+
+	public void testInitialBindingsExec() {
+		String data =
+			"@prefix :   <http://example.com/> .\n" +
+			"@prefix xsd:  <" + XSD.getURI() + "> .\n" +
+			"@prefix foaf: <" + FOAF.getURI() + "> .\n" +
+			":Sepp foaf:name \"Sepp\" ;\n" +
+			"	foaf:knows :Phil , :Tim , :Sandra .\n" +
+			":Claudia foaf:name \"Claudia\" ;\n" +
+			"	foaf:mbox <mailto:claudia@example.com> ;\n" +
+			"	foaf:knows :Sepp , :Sandra .\n" +
+			":Phil foaf:name \"Phil\" ;\n" +
+			"	foaf:knows :Sepp .\n" +
+			":Tim foaf:name \"Tim\" .";
+		
+		Model m = ModelFactory.createDefaultModel();
+		m.read(new StringReader(data), null, "N3");
+		
+		String qry =
+			"PREFIX  :   <http://example.com/>\n" +
+			"PREFIX  foaf: <" + FOAF.getURI() + ">\n" +
+			"PREFIX  xsd:  <" + XSD.getURI() + ">\n" +
+			"\n" +
+			"SELECT ?name ?mbox ?knows \n" +
+			"WHERE {\n" +
+			"  { ?p foaf:name ?name . }\n" +
+			"  OPTIONAL { ?p foaf:mbox ?mbox . }\n" +
+			"  { ?p foaf:knows ?knows . }\n" +
+			"} BINDINGS ?knows {\n" +
+			"  :Tim .\n" +
+			"  :Sepp .\n" +
+			"}\n" +
+			"ORDER BY ?name\n";
+		
+		Query q = QueryFactory.create(qry, Syntax.syntaxARQ);
+		TableN n = q.getInitialBindingTable();
+		System.out.println(n);
+		
+		QueryExecution qe = QueryExecutionFactory.create(q, m);
+		ResultSet r = qe.execSelect();
+		ResultSetFormatter.out(r);
+		
+		// still works with traditional initial binding:
+		QuerySolutionMap sol = new QuerySolutionMap();
+		sol.add("knows", m.getResource("http://example.com/Tim"));
+		qe = QueryExecutionFactory.create(q, m, sol);
+		r = qe.execSelect();
+		ResultSetFormatter.out(r);
+	}
+	
+	public void testExplainSelectQuery() {
+		String qry = "PREFIX  rdf:  <" + RDF.getURI() + ">\n\n" +
+				"EXPLAIN SELECT DISTINCT  ?t\nWHERE\n  { ?s rdf:type ?t}\nORDER BY ?t\n";
+		Query q = QueryFactory.create(qry, Syntax.syntaxARQ);
+		assertEquals(qry, q.toString());
+		
+		QueryExecution qe = QueryExecutionFactory.create(q, ModelFactory.createDefaultModel());
+		Model m = qe.execExplain();
+		m.write(System.out, "N3");
+	}
+	
+	public void testDescribeSelfQuery() {
+		String qry = "DESCRIBE SELF\n";
+		Query q = QueryFactory.create(qry, Syntax.syntaxARQ);
+		assertEquals(qry, q.toString());
+		
+		Dataset ds = new DatasetImpl(FileManager.get().loadModel(RDF.getURI())); // load RDF vocab for testing triples count...
+		// better fixture (may become offline:)
+		ds.setVoidDescURL("http://void-impl.googlecode.com/svn/trunk/ve/void-seeds.rdf");
+		QueryExecution qe = QueryExecutionFactory.create(q, ds);
+		Model m = qe.execDescribe();
+		m.write(System.out, "Turtle");
+	}
+	
+	public void testDescribeDatasetQuery() {
+		String qry = "DESCRIBE DATASET\n";
+		Query q = QueryFactory.create(qry, Syntax.syntaxARQ);
+		assertEquals(qry, q.toString());
+		
+		Dataset ds = new DatasetImpl(ModelFactory.createDefaultModel());
+		// better fixture (may become offline:)
+		ds.setVoidDescURL("http://void-impl.googlecode.com/svn/trunk/ve/void-seeds.rdf");
+		QueryExecution qe = QueryExecutionFactory.create(q, ds);
+		Model m = qe.execDescribe();
+		m.write(System.out, "Turtle");
+	}
+}
Index: src/com/hp/hpl/jena/sparql/engine/QueryExecutionBase.java
===================================================================
--- src/com/hp/hpl/jena/sparql/engine/QueryExecutionBase.java	(revision 6629)
+++ src/com/hp/hpl/jena/sparql/engine/QueryExecutionBase.java	(working copy)
@@ -43,7 +43,11 @@
 import com.hp.hpl.jena.sparql.util.DatasetUtils;
 import com.hp.hpl.jena.sparql.util.ModelUtils;
 import com.hp.hpl.jena.sparql.util.graph.GraphUtils;
+import com.hp.hpl.jena.sparql.vocabulary.SparqlExplainVocab;
 import com.hp.hpl.jena.util.FileManager;
+import com.hp.hpl.jena.vocabulary.RDF;
+import com.hp.hpl.jena.vocabulary.RDFS;
+import com.hp.hpl.jena.vocabulary.XSD;
 
 /** All the SPARQL query result forms made from a graph-level execution object */ 
 
@@ -87,6 +91,23 @@
             plan.close() ;
     }
 
+    // AndyL
+    public Model execExplain() {
+    	Plan plan = getPlan();
+    	plan.getOp();
+    	Model explain = ModelFactory.createDefaultModel();
+    	explain.setNsPrefix("spx", SparqlExplainVocab.getURI());
+    	explain.setNsPrefix("xsd", XSD.getURI());
+    	explain.setNsPrefix("rdf", RDF.getURI());
+    	explain.setNsPrefix("rdfs", RDFS.getURI());
+    	Resource expl = explain.createResource(null, SparqlExplainVocab.QueryExplanation);
+    	expl.addLiteral(SparqlExplainVocab.queryString, query.toString());
+    	
+    	String pl = plan.getOp().toString() + "\n" + plan.toString();
+    	expl.addLiteral(SparqlExplainVocab.plan, pl);
+    	return explain;
+    }
+    
     public ResultSet execSelect()
     {
         if ( ! query.isSelectType() )
@@ -94,7 +115,6 @@
         return execResultSet() ;
     }
 
-
     // Construct
     public Model execConstruct()
     { return execConstruct(GraphUtils.makeJenaDefaultModel()) ; }
@@ -135,79 +155,140 @@
     }
 
     public Model execDescribe()
-    { return execDescribe(GraphUtils.makeJenaDefaultModel()) ; }
-
+    { 
+  		return execDescribe(GraphUtils.makeJenaDefaultModel()) ; 
+    }
 
     public Model execDescribe(Model model)
     {
         if ( ! query.isDescribeType() )
             throw new QueryExecException("Attempt to get a DESCRIBE result from a "+labelForQuery(query)+" query") ; 
         //Was: query.setQueryResultStar(true) ; but why?
-        query.setResultVars() ;
-        // If there was no WhereClause, use an empty pattern (one solution, no columns). 
-        if ( query.getQueryPattern() == null )
-            query.setQueryPattern(new ElementGroup()) ;
         
-        Set<RDFNode> set = new HashSet<RDFNode>() ;
-
-        //May return null (no query pattern) 
-        ResultSet qRes = execResultSet() ;
-
-        // Prefixes for result (after initialization)
-        insertPrefixesInto(model) ;
-        if ( qRes != null )
-        {
-            for ( ; qRes.hasNext() ; )
-            {
-                QuerySolution rb = qRes.nextSolution() ;
-                for ( String varName : query.getResultVars() )
-                {
-                    RDFNode n = rb.get(varName) ;
-                    set.add(n) ;
-                }
-            }
-            this.close() ;
-        }
-
-        if ( query.getResultURIs() != null )
-        {
-            // Any URIs in the DESCRIBE
-            for (Node n : query.getResultURIs())
-            {
-                // Need to make dataset available to describe handlers.
-                RDFNode rNode = ModelUtils.convertGraphNodeToRDFNode(n, dataset.getDefaultModel()) ;
-                set.add(rNode) ;
-            }
-        }
+        // AndyL DESCRIBE SELF
+        switch(query.getDescribeMode()) {
+        
+        case Query.DESCRIBE_SELF:
+    		String DOSE_NS = "http://darq.sf.net/dose/0.1#"; // Bastian Quilitz, http://darq.sourceforge.net/
+        	String SADDLE_NS = "http://www.w3.org/2005/03/saddle/#"; // Kendall Clark, http://www.w3.org/2001/sw/DataAccess/proto-wd/saddle.html
+        	
+        	model.setNsPrefix("rdf", RDF.getURI());
+        	model.setNsPrefix("rdfs", RDFS.getURI());
+        	model.setNsPrefix("xsd", XSD.getURI());
+        	model.setNsPrefix("sd", DOSE_NS);
+        	model.setNsPrefix("saddle", SADDLE_NS);
+        	
+        	Resource service = model.createResource(null, model.getResource(DOSE_NS + "Service"));
+        	service.addLiteral(RDFS.label, "Joseki SPARQL Endpoint");
+        	
+        	long totalTriples = dataset.getDefaultModel().size();
+        	Iterator<String> names = dataset.listNames();
+        	while (names.hasNext())
+        		totalTriples += dataset.getNamedModel(names.next()).size();
+        	service.addLiteral(model.getProperty(DOSE_NS + "totalTriples"), totalTriples);
+        	
+//no endpoint info here        	service.addProperty(desc.getProperty(DOSE_NS + "url"), dataset.get)
+        	
+        	Resource sparqlLang = model.createResource();
+        	sparqlLang.addLiteral(RDFS.label, "SPARQL");
+        	sparqlLang.addProperty(model.getProperty(SADDLE_NS + "spec"), model.createResource("http://www.w3.org/TR/rdf-sparql-query/"));
+        	service.addProperty(model.getProperty(SADDLE_NS + "queryLanguage"), sparqlLang);
 
-        // Create new handlers for this process.
-        List<DescribeHandler> dhList = DescribeHandlerRegistry.get().newHandlerList() ;
+        	Resource resultRDF = model.createResource();
+        	resultRDF.addLiteral(RDFS.label, "RDF/XML");
+        	resultRDF.addLiteral(model.getProperty(SADDLE_NS + "mediaType"), "application/rdf+xml");
+        	resultRDF.addProperty(model.getProperty(SADDLE_NS + "spec"), RDFS.getURI());
+        	service.addProperty(model.getProperty(SADDLE_NS + "resultFormat"), resultRDF);
 
-        getContext().put(ARQConstants.sysCurrentDataset, getDataset()) ;
-        // Notify start of describe phase
-        for (DescribeHandler dh : dhList)
-            dh.start(model, getContext()) ;
+        	Resource resultXML = model.createResource();
+        	resultXML.addLiteral(RDFS.label, "SPARQL/XML");
+        	resultXML.addLiteral(model.getProperty(SADDLE_NS + "mediaType"), "application/sparql-results+xml");
+        	resultXML.addProperty(model.getProperty(SADDLE_NS + "spec"), model.createResource("http://www.w3.org/TR/rdf-sparql-XMLres/"));
+        	service.addProperty(model.getProperty(SADDLE_NS + "resultFormat"), resultXML);
 
-        // Do describe for each resource found.
-        for (Iterator<RDFNode> iter = set.iterator() ; iter.hasNext() ;)
-        {
-            RDFNode n = iter.next() ;
+        	Resource resultJSON = model.createResource();
+        	resultJSON.addLiteral(RDFS.label, "SPARQL/JSON");
+        	resultJSON.addLiteral(model.getProperty(SADDLE_NS + "mediaType"), "application/sparql-results+json");
+        	resultJSON.addProperty(model.getProperty(SADDLE_NS + "spec"), model.createResource("http://www.w3.org/TR/rdf-sparql-json-res/"));
+        	service.addProperty(model.getProperty(SADDLE_NS + "resultFormat"), resultJSON);
+        	
+        	if (dataset.getVoidDescURL() != null)
+        		service.addProperty(model.getProperty(SADDLE_NS + "dataSet"), model.createResource(dataset.getVoidDescURL()));
 
-            if ( n instanceof Resource )
-            {
-                for (DescribeHandler dh : dhList)
-                    dh.describe((Resource)n) ;
-            }
-            else
-                // Can't describe literals
-                continue ;
+        	return model;
+        
+        case Query.DESCRIBE_DATASET:
+        	if (dataset.getVoidDescURL() != null)
+        	model = FileManager.get().loadModel(dataset.getVoidDescURL());
+        	return model;
+        	
+        default:
+	        query.setResultVars() ;
+	        // If there was no WhereClause, use an empty pattern (one solution, no columns). 
+	        if ( query.getQueryPattern() == null )
+	            query.setQueryPattern(new ElementGroup()) ;
+	        
+	        Set<RDFNode> set = new HashSet<RDFNode>() ;
+	
+	        //May return null (no query pattern) 
+	        ResultSet qRes = execResultSet() ;
+	
+	        // Prefixes for result (after initialization)
+	        insertPrefixesInto(model) ;
+	        if ( qRes != null )
+	        {
+	            for ( ; qRes.hasNext() ; )
+	            {
+	                QuerySolution rb = qRes.nextSolution() ;
+	                for ( String varName : query.getResultVars() )
+	                {
+	                    RDFNode n = rb.get(varName) ;
+	                    set.add(n) ;
+	                }
+	            }
+	            this.close() ;
+	        }
+	
+	        if ( query.getResultURIs() != null )
+	        {
+	            // Any URIs in the DESCRIBE
+	            for (Node n : query.getResultURIs())
+	            {
+	                // Need to make dataset available to describe handlers.
+	                RDFNode rNode = ModelUtils.convertGraphNodeToRDFNode(n, dataset.getDefaultModel()) ;
+	                set.add(rNode) ;
+	            }
+	        }
+	
+	        // Create new handlers for this process.
+	        List<DescribeHandler> dhList = DescribeHandlerRegistry.get().newHandlerList() ;
+	
+	        getContext().put(ARQConstants.sysCurrentDataset, getDataset()) ;
+	        // Notify start of describe phase
+	        for (DescribeHandler dh : dhList)
+	            dh.start(model, getContext()) ;
+	
+	        // Do describe for each resource found.
+	        for (Iterator<RDFNode> iter = set.iterator() ; iter.hasNext() ;)
+	        {
+	            RDFNode n = iter.next() ;
+	
+	            if ( n instanceof Resource )
+	            {
+	                for (DescribeHandler dh : dhList)
+	                    dh.describe((Resource)n) ;
+	            }
+	            else
+	                // Can't describe literals
+	                continue ;
+	        }
+	
+	        for (DescribeHandler dh : dhList)
+	            dh.finish() ;
+	
+	        this.close() ;
+	        return model ;
         }
-
-        for (DescribeHandler dh : dhList)
-            dh.start(model, getContext()) ;
-
-        this.close() ;
-        return model ; 
     }
 
     public boolean execAsk()
Index: src/com/hp/hpl/jena/sparql/engine/main/iterator/QueryIterJoin.java
===================================================================
--- src/com/hp/hpl/jena/sparql/engine/main/iterator/QueryIterJoin.java	(revision 6629)
+++ src/com/hp/hpl/jena/sparql/engine/main/iterator/QueryIterJoin.java	(working copy)
@@ -8,13 +8,14 @@
 
 import com.hp.hpl.jena.sparql.engine.ExecutionContext;
 import com.hp.hpl.jena.sparql.engine.QueryIterator;
+import com.hp.hpl.jena.sparql.expr.ExprList;
 
 /** Join by materializing the RHS - this is not streamed */
 public class QueryIterJoin extends QueryIterJoinBase
 {
-    public QueryIterJoin(QueryIterator left, QueryIterator right, ExecutionContext qCxt)
+    public QueryIterJoin(QueryIterator left, QueryIterator right, ExprList exprs, ExecutionContext qCxt)
     {
-        super(left, right, null, qCxt) ;
+        super(left, right, exprs, qCxt) ;
     }
     
     @Override
Index: src/com/hp/hpl/jena/sparql/algebra/opt/TransformThetaJoins.java
===================================================================
--- src/com/hp/hpl/jena/sparql/algebra/opt/TransformThetaJoins.java	(revision 0)
+++ src/com/hp/hpl/jena/sparql/algebra/opt/TransformThetaJoins.java	(revision 0)
@@ -0,0 +1,31 @@
+/**
+ * 
+ */
+package com.hp.hpl.jena.sparql.algebra.opt;
+
+import com.hp.hpl.jena.sparql.algebra.Op;
+import com.hp.hpl.jena.sparql.algebra.Transform;
+import com.hp.hpl.jena.sparql.algebra.TransformCopy;
+import com.hp.hpl.jena.sparql.algebra.op.OpFilter;
+import com.hp.hpl.jena.sparql.algebra.op.OpJoin;
+import com.hp.hpl.jena.sparql.algebra.op.OpLeftJoin;
+
+/**
+ * @author dorgon
+ *
+ */
+public class TransformThetaJoins extends TransformCopy implements Transform {
+
+	@Override
+	public Op transform(OpFilter opFilter, Op sub) {
+		if (sub instanceof OpJoin) {
+			((OpJoin) sub).setExprs(opFilter.getExprs());
+			return sub; // conditional OpJoin, join applies any filter expressions, can drop filter
+		} else if (sub instanceof OpLeftJoin) {
+			((OpLeftJoin) sub).addExprs(opFilter.getExprs());
+			return sub; // added conditions to OpLeftJoin, join applies any filter expressions, can drop filter
+		} else
+			return super.transform(opFilter, sub);
+	}
+	
+}
Index: src/com/hp/hpl/jena/sparql/engine/http/HttpQuery.java
===================================================================
--- src/com/hp/hpl/jena/sparql/engine/http/HttpQuery.java	(revision 6629)
+++ src/com/hp/hpl/jena/sparql/engine/http/HttpQuery.java	(working copy)
@@ -179,6 +179,11 @@
         {
             httpConnection = (HttpURLConnection) target.openConnection();
             httpConnection.setRequestProperty("Accept", contentTypeResult) ;
+            httpConnection.setConnectTimeout(5000); // 5 seconds
+            log.debug("Connection timeout: " + httpConnection.getConnectTimeout());
+            httpConnection.setReadTimeout(600000); // 10 minutes
+            log.debug("Read timeout: " + httpConnection.getReadTimeout());
+            
             // By default, following 3xx redirects is true
             //conn.setFollowRedirects(true) ;
             basicAuthentication(httpConnection) ;
Index: src/com/hp/hpl/jena/sparql/core/DataSourceImpl.java
===================================================================
--- src/com/hp/hpl/jena/sparql/core/DataSourceImpl.java	(revision 6629)
+++ src/com/hp/hpl/jena/sparql/core/DataSourceImpl.java	(working copy)
@@ -33,6 +33,9 @@
     // Cache graph => model so returned models are the same (==)
     private Map<Graph, Model> cache = new HashMap<Graph, Model>() ;      
 
+    // AndyL
+    private String voidDescURL = null;
+    
     public DataSourceImpl()
     { this.dsg = new DataSourceGraphImpl() ; }
 
@@ -69,6 +72,16 @@
     
     public DatasetGraph asDatasetGraph() { return dsg ; }
 
+    // AndyL
+    public String getVoidDescURL() {
+    	return voidDescURL;
+    }
+    
+    // AndyL
+    public void setVoidDescURL(String url) {
+    	this.voidDescURL = url;
+    }
+    
     public Model getNamedModel(String uri)
     { 
         Node n = Node.createURI(uri) ;
Index: src/com/hp/hpl/jena/sparql/vocabulary/SparqlExplainVocab.java
===================================================================
--- src/com/hp/hpl/jena/sparql/vocabulary/SparqlExplainVocab.java	(revision 0)
+++ src/com/hp/hpl/jena/sparql/vocabulary/SparqlExplainVocab.java	(revision 0)
@@ -0,0 +1,74 @@
+/* CVS $Id: $ */
+package com.hp.hpl.jena.sparql.vocabulary; 
+import com.hp.hpl.jena.rdf.model.*;
+ 
+/**
+ * Vocabulary definitions from file:Vocabularies/sparql-explain.ttl 
+ * @author Auto-generated by schemagen on 24 Jul 2009 14:52 
+ */
+public class SparqlExplainVocab {
+    /** <p>The RDF model that holds the vocabulary terms</p> */
+    private static Model m_model = ModelFactory.createDefaultModel();
+    
+    /** <p>The namespace of the vocabulary as a string</p> */
+    public static final String NS = "http://purl.org/NET/sparql-explain#";
+    
+    /** <p>The namespace of the vocabulary as a string</p>
+     *  @see #NS */
+    public static String getURI() {return NS;}
+    
+    /** <p>The namespace of the vocabulary as a resource</p> */
+    public static final Resource NAMESPACE = m_model.createResource( NS );
+    
+    /** <p>the estimated number of query solutions (should be provided by implementations)</p> */
+    public static final Property expectedSolutions = m_model.createProperty( "http://purl.org/NET/sparql-explain#expectedSolutions" );
+    
+    /** <p>the estimated number of triples (should be provided by implementations)</p> */
+    public static final Property expectedTriples = m_model.createProperty( "http://purl.org/NET/sparql-explain#expectedTriples" );
+    
+    /** <p>guaranteed upper bound, if 0 there are no solutions at all, if omitted clients 
+     *  should assume positive infinity</p>
+     */
+    public static final Property maxSolutions = m_model.createProperty( "http://purl.org/NET/sparql-explain#maxSolutions" );
+    
+    /** <p>guaranteed upper bound, if 0 no triples are returned at all, if omitted clients 
+     *  should assume positive infinity</p>
+     */
+    public static final Property maxTriples = m_model.createProperty( "http://purl.org/NET/sparql-explain#maxTriples" );
+    
+    /** <p>guaranteed lower bound, if 0 there may be no solutions at all, if omitted 
+     *  clients should assume 0</p>
+     */
+    public static final Property minSolutions = m_model.createProperty( "http://purl.org/NET/sparql-explain#minSolutions" );
+    
+    /** <p>guaranteed lower bound, if 0 there may be no triples returned at all, if omitted 
+     *  clients should assume 0</p>
+     */
+    public static final Property minTriples = m_model.createProperty( "http://purl.org/NET/sparql-explain#minTriples" );
+    
+    /** <p>implementation-specific details for the query plan (typically as a string)</p> */
+    public static final Property plan = m_model.createProperty( "http://purl.org/NET/sparql-explain#plan" );
+    
+    public static final Property queryString = m_model.createProperty( "http://purl.org/NET/sparql-explain#queryString" );
+    
+    public static final Property querySyntax = m_model.createProperty( "http://purl.org/NET/sparql-explain#querySyntax" );
+    
+    /** <p>latency in milliseconds until the first result will be available, excluding 
+     *  transfer</p>
+     */
+    public static final Property timeToFirst = m_model.createProperty( "http://purl.org/NET/sparql-explain#timeToFirst" );
+    
+    /** <p>latency in milliseconds until subsequent results are available, excluding 
+     *  transfer</p>
+     */
+    public static final Property timeToNext = m_model.createProperty( "http://purl.org/NET/sparql-explain#timeToNext" );
+    
+    /** <p>total execution time in milliseconds for processing and blind iteration of 
+     *  results, excluding transfer; ~= timeToFirst + (expectedSolutions-1)*timeToNext</p>
+     */
+    public static final Property timeTotal = m_model.createProperty( "http://purl.org/NET/sparql-explain#timeTotal" );
+    
+    /** <p>Explanation of a SPARQL query.</p> */
+    public static final Resource QueryExplanation = m_model.createResource( "http://purl.org/NET/sparql-explain#QueryExplanation" );
+    
+}
Index: src/com/hp/hpl/jena/sparql/lang/arq/Token.java
===================================================================
--- src/com/hp/hpl/jena/sparql/lang/arq/Token.java	(revision 6629)
+++ src/com/hp/hpl/jena/sparql/lang/arq/Token.java	(working copy)
@@ -95,7 +95,7 @@
   /**
    * Returns the image.
    */
-  @Override public String toString()
+  public String toString()
   {
      return image;
   }
@@ -126,4 +126,4 @@
   }
 
 }
-/* JavaCC - OriginalChecksum=efd6c5ae861b2396520a0582e9998015 (do not edit this line) */
+/* JavaCC - OriginalChecksum=43120fc1e082adb1a60a5376c00a203a (do not edit this line) */
Index: src/com/hp/hpl/jena/sparql/algebra/AlgebraGenerator.java
===================================================================
--- src/com/hp/hpl/jena/sparql/algebra/AlgebraGenerator.java	(revision 6629)
+++ src/com/hp/hpl/jena/sparql/algebra/AlgebraGenerator.java	(working copy)
@@ -15,6 +15,7 @@
 import com.hp.hpl.jena.sparql.ARQInternalErrorException;
 import com.hp.hpl.jena.sparql.algebra.op.*;
 import com.hp.hpl.jena.sparql.algebra.opt.TransformSimplify;
+import com.hp.hpl.jena.sparql.algebra.table.TableN;
 import com.hp.hpl.jena.sparql.core.BasicPattern;
 import com.hp.hpl.jena.sparql.core.PathBlock;
 import com.hp.hpl.jena.sparql.core.Var;
@@ -68,6 +69,9 @@
     public Op compile(Query query)
     {
         Op pattern = compile(query.getQueryPattern()) ;     // Not compileElement - may need to apply simplification.
+        TableN initBindings = query.getInitialBindingTable();
+        if (initBindings != null)
+        	pattern = OpSequence.create(pattern, OpTable.create(initBindings));
         Op op = compileModifiers(query, pattern) ;
         return op ;
     }
Index: src/com/hp/hpl/jena/sparql/engine/http/QueryEngineHTTP.java
===================================================================
--- src/com/hp/hpl/jena/sparql/engine/http/QueryEngineHTTP.java	(revision 6629)
+++ src/com/hp/hpl/jena/sparql/engine/http/QueryEngineHTTP.java	(working copy)
@@ -119,6 +119,12 @@
         return rs ;
     }
 
+    // AndyL
+    public Model execExplain()				 { return execExplain(GraphUtils.makeJenaDefaultModel()) ; }
+    
+    // AndyL
+    public Model execExplain(Model model)    { return execModel(model) ; }
+    
     public Model execConstruct()             { return execConstruct(GraphUtils.makeJenaDefaultModel()) ; }
     
     public Model execConstruct(Model model)  { return execModel(model) ; }
Index: src/com/hp/hpl/jena/graph/TrackedNode.java
===================================================================
--- src/com/hp/hpl/jena/graph/TrackedNode.java	(revision 0)
+++ src/com/hp/hpl/jena/graph/TrackedNode.java	(revision 0)
@@ -0,0 +1,294 @@
+/**
+ * Copyright 2007-2008 Institute for Applied Knowledge Processing, Johannes Kepler University Linz
+ *  
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.hp.hpl.jena.graph;
+
+import com.hp.hpl.jena.datatypes.RDFDatatype;
+import com.hp.hpl.jena.graph.Node;
+import com.hp.hpl.jena.graph.NodeVisitor;
+import com.hp.hpl.jena.graph.impl.LiteralLabel;
+import com.hp.hpl.jena.rdf.model.AnonId;
+import com.hp.hpl.jena.rdf.model.Resource;
+import com.hp.hpl.jena.shared.PrefixMapping;
+
+/**
+ * @author dorgon, Andreas Langegger, al@jku.at
+ *
+ */
+public class TrackedNode extends Node {
+	private final Node wrapped;
+	private final Node source;
+	
+	/**
+	 * provenance tracking of nodes
+	 */
+	public TrackedNode(Node n, Node source) {
+		super(n.label);
+		this.wrapped = n;
+		this.source = source;
+	}
+
+	public Node getProvenanceUri() {
+		return source;
+	}
+	
+	public static Node getProvenanceUri(Node n) {
+		if (n instanceof TrackedNode)
+			return ((TrackedNode) n).getProvenanceUri();
+		else return null;
+	}
+	
+	/**
+	 * @param o
+	 * @return
+	 * @see com.hp.hpl.jena.graph.Node#equals(java.lang.Object)
+	 */
+	public boolean equals(Object o) {
+		return wrapped.equals(o);
+	}
+
+	/**
+	 * @return
+	 * @see com.hp.hpl.jena.graph.Node#getBlankNodeId()
+	 */
+	public AnonId getBlankNodeId() {
+		return wrapped.getBlankNodeId();
+	}
+
+	/**
+	 * @return
+	 * @see com.hp.hpl.jena.graph.Node#getBlankNodeLabel()
+	 */
+	public String getBlankNodeLabel() {
+		return wrapped.getBlankNodeLabel();
+	}
+
+	/**
+	 * @return
+	 * @see com.hp.hpl.jena.graph.Node#getIndexingValue()
+	 */
+	public Object getIndexingValue() {
+		return wrapped.getIndexingValue();
+	}
+
+	/**
+	 * @return
+	 * @see com.hp.hpl.jena.graph.Node#getLiteral()
+	 */
+	public LiteralLabel getLiteral() {
+		return wrapped.getLiteral();
+	}
+
+	/**
+	 * @return
+	 * @see com.hp.hpl.jena.graph.Node#getLiteralDatatype()
+	 */
+	public RDFDatatype getLiteralDatatype() {
+		return wrapped.getLiteralDatatype();
+	}
+
+	/**
+	 * @return
+	 * @see com.hp.hpl.jena.graph.Node#getLiteralDatatypeURI()
+	 */
+	public String getLiteralDatatypeURI() {
+		return wrapped.getLiteralDatatypeURI();
+	}
+
+	/**
+	 * @return
+	 * @see com.hp.hpl.jena.graph.Node#getLiteralIsXML()
+	 */
+	public boolean getLiteralIsXML() {
+		return wrapped.getLiteralIsXML();
+	}
+
+	/**
+	 * @return
+	 * @see com.hp.hpl.jena.graph.Node#getLiteralLanguage()
+	 */
+	public String getLiteralLanguage() {
+		return wrapped.getLiteralLanguage();
+	}
+
+	/**
+	 * @return
+	 * @see com.hp.hpl.jena.graph.Node#getLiteralLexicalForm()
+	 */
+	public String getLiteralLexicalForm() {
+		return wrapped.getLiteralLexicalForm();
+	}
+
+	/**
+	 * @return
+	 * @see com.hp.hpl.jena.graph.Node#getLiteralValue()
+	 */
+	public Object getLiteralValue() {
+		return wrapped.getLiteralValue();
+	}
+
+	/**
+	 * @return
+	 * @see com.hp.hpl.jena.graph.Node#getLocalName()
+	 */
+	public String getLocalName() {
+		return wrapped.getLocalName();
+	}
+
+	/**
+	 * @return
+	 * @see com.hp.hpl.jena.graph.Node#getName()
+	 */
+	public String getName() {
+		return wrapped.getName();
+	}
+
+	/**
+	 * @return
+	 * @see com.hp.hpl.jena.graph.Node#getNameSpace()
+	 */
+	public String getNameSpace() {
+		return wrapped.getNameSpace();
+	}
+
+	/**
+	 * @return
+	 * @see com.hp.hpl.jena.graph.Node#getURI()
+	 */
+	public String getURI() {
+		return wrapped.getURI();
+	}
+
+	/**
+	 * @return
+	 * @see com.hp.hpl.jena.graph.Node#hashCode()
+	 */
+	public int hashCode() {
+		return wrapped.hashCode();
+	}
+
+	/**
+	 * @param uri
+	 * @return
+	 * @see com.hp.hpl.jena.graph.Node#hasURI(java.lang.String)
+	 */
+	public boolean hasURI(String uri) {
+		return wrapped.hasURI(uri);
+	}
+
+	/**
+	 * @return
+	 * @see com.hp.hpl.jena.graph.Node#isBlank()
+	 */
+	public boolean isBlank() {
+		return wrapped.isBlank();
+	}
+
+	/**
+	 * @return
+	 * @see com.hp.hpl.jena.graph.Node#isConcrete()
+	 */
+	public boolean isConcrete() {
+		return wrapped.isConcrete();
+	}
+
+	/**
+	 * @return
+	 * @see com.hp.hpl.jena.graph.Node#isLiteral()
+	 */
+	public boolean isLiteral() {
+		return wrapped.isLiteral();
+	}
+
+	/**
+	 * @return
+	 * @see com.hp.hpl.jena.graph.Node#isURI()
+	 */
+	public boolean isURI() {
+		return wrapped.isURI();
+	}
+
+	/**
+	 * @return
+	 * @see com.hp.hpl.jena.graph.Node#isVariable()
+	 */
+	public boolean isVariable() {
+		return wrapped.isVariable();
+	}
+
+	/**
+	 * @param other
+	 * @return
+	 * @see com.hp.hpl.jena.graph.Node#matches(com.hp.hpl.jena.graph.Node)
+	 */
+	public boolean matches(Node other) {
+		return wrapped.matches(other);
+	}
+
+	/**
+	 * @param o
+	 * @return
+	 * @see com.hp.hpl.jena.graph.Node#sameValueAs(java.lang.Object)
+	 */
+	public boolean sameValueAs(Object o) {
+		return wrapped.sameValueAs(o);
+	}
+
+	/**
+	 * @return
+	 * @see com.hp.hpl.jena.graph.Node#toString()
+	 */
+	public String toString() {
+		return wrapped.toString();
+	}
+
+	/**
+	 * @param quoting
+	 * @return
+	 * @see com.hp.hpl.jena.graph.Node#toString(boolean)
+	 */
+	public String toString(boolean quoting) {
+		return wrapped.toString(quoting);
+	}
+
+	/**
+	 * @param pm
+	 * @param quoting
+	 * @return
+	 * @see com.hp.hpl.jena.graph.Node#toString(com.hp.hpl.jena.shared.PrefixMapping, boolean)
+	 */
+	public String toString(PrefixMapping pm, boolean quoting) {
+		return wrapped.toString(pm, quoting);
+	}
+
+	/**
+	 * @param pm
+	 * @return
+	 * @see com.hp.hpl.jena.graph.Node#toString(com.hp.hpl.jena.shared.PrefixMapping)
+	 */
+	public String toString(PrefixMapping pm) {
+		return wrapped.toString(pm);
+	}
+
+	/**
+	 * @param v
+	 * @return
+	 * @see com.hp.hpl.jena.graph.Node#visitWith(com.hp.hpl.jena.graph.NodeVisitor)
+	 */
+	public Object visitWith(NodeVisitor v) {
+		return wrapped.visitWith(v);
+	}
+	
+}
Index: src/com/hp/hpl/jena/sparql/core/DatasetImpl.java
===================================================================
--- src/com/hp/hpl/jena/sparql/core/DatasetImpl.java	(revision 6629)
+++ src/com/hp/hpl/jena/sparql/core/DatasetImpl.java	(working copy)
@@ -28,6 +28,7 @@
     protected DatasetGraph dsg = null ;
     // Cache graph => model so returned models are the same (==)
     private Map<Graph, Model> cache = new HashMap<Graph, Model>() ;      
+    private String voidDescURL = null;
 
     public DatasetImpl(Model model)
     {
@@ -60,6 +61,16 @@
         return dsg.containsGraph(Node.createURI(uri)) ;
     }
 
+    // AndyL
+    public String getVoidDescURL() {
+    	return voidDescURL;
+    }
+    
+    // AndyL
+    public void setVoidDescURL(String url) {
+    	this.voidDescURL = url;
+    }
+    
     public void close()
     {
         cache = null ;
Index: lib/jenatest.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: lib/jena.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: src/com/hp/hpl/jena/sparql/lang/arq/ARQParserConstants.java
===================================================================
--- src/com/hp/hpl/jena/sparql/lang/arq/ARQParserConstants.java	(revision 6629)
+++ src/com/hp/hpl/jena/sparql/lang/arq/ARQParserConstants.java	(working copy)
@@ -7,7 +7,7 @@
 package com.hp.hpl.jena.sparql.lang.arq ;
 
 
-/**
+/** 
  * Token literal values and constants.
  * Generated by org.javacc.parser.OtherFilesGen#start()
  */
@@ -44,241 +44,251 @@
   /** RegularExpression Id. */
   int PREFIX = 19;
   /** RegularExpression Id. */
-  int SELECT = 20;
+  int EXPLAIN = 20;
+  /** RegularExpression Id. */
+  int SELECT = 21;
   /** RegularExpression Id. */
-  int DISTINCT = 21;
+  int DISTINCT = 22;
   /** RegularExpression Id. */
-  int REDUCED = 22;
+  int REDUCED = 23;
   /** RegularExpression Id. */
-  int DESCRIBE = 23;
+  int DESCRIBE = 24;
   /** RegularExpression Id. */
-  int CONSTRUCT = 24;
+  int CONSTRUCT = 25;
   /** RegularExpression Id. */
-  int ASK = 25;
+  int ASK = 26;
   /** RegularExpression Id. */
-  int LIMIT = 26;
+  int SELF = 27;
   /** RegularExpression Id. */
-  int OFFSET = 27;
+  int DATASET = 28;
   /** RegularExpression Id. */
-  int ORDER = 28;
+  int LIMIT = 29;
   /** RegularExpression Id. */
-  int BY = 29;
+  int OFFSET = 30;
   /** RegularExpression Id. */
-  int ASC = 30;
+  int ORDER = 31;
   /** RegularExpression Id. */
-  int DESC = 31;
+  int BY = 32;
   /** RegularExpression Id. */
-  int NAMED = 32;
+  int BINDINGS = 33;
   /** RegularExpression Id. */
-  int FROM = 33;
+  int ASC = 34;
   /** RegularExpression Id. */
-  int WHERE = 34;
+  int DESC = 35;
   /** RegularExpression Id. */
-  int AND = 35;
+  int NAMED = 36;
   /** RegularExpression Id. */
-  int GRAPH = 36;
+  int FROM = 37;
   /** RegularExpression Id. */
-  int OPTIONAL = 37;
+  int WHERE = 38;
   /** RegularExpression Id. */
-  int UNION = 38;
+  int AND = 39;
   /** RegularExpression Id. */
-  int SERVICE = 39;
+  int GRAPH = 40;
   /** RegularExpression Id. */
-  int EXISTS = 40;
+  int OPTIONAL = 41;
   /** RegularExpression Id. */
-  int AS = 41;
+  int UNION = 42;
   /** RegularExpression Id. */
-  int LET = 42;
+  int SERVICE = 43;
   /** RegularExpression Id. */
-  int GROUP = 43;
+  int EXISTS = 44;
   /** RegularExpression Id. */
-  int HAVING = 44;
+  int AS = 45;
   /** RegularExpression Id. */
-  int AGG = 45;
+  int LET = 46;
   /** RegularExpression Id. */
-  int COUNT = 46;
+  int GROUP = 47;
   /** RegularExpression Id. */
-  int MIN = 47;
+  int HAVING = 48;
   /** RegularExpression Id. */
-  int MAX = 48;
+  int AGG = 49;
   /** RegularExpression Id. */
-  int SUM = 49;
+  int COUNT = 50;
   /** RegularExpression Id. */
-  int AVG = 50;
+  int MIN = 51;
   /** RegularExpression Id. */
-  int STDDEV = 51;
+  int MAX = 52;
   /** RegularExpression Id. */
-  int FETCH = 52;
+  int SUM = 53;
   /** RegularExpression Id. */
-  int FILTER = 53;
+  int AVG = 54;
   /** RegularExpression Id. */
-  int BOUND = 54;
+  int STDDEV = 55;
   /** RegularExpression Id. */
-  int STR = 55;
+  int FETCH = 56;
   /** RegularExpression Id. */
-  int DTYPE = 56;
+  int FILTER = 57;
   /** RegularExpression Id. */
-  int LANG = 57;
+  int BOUND = 58;
   /** RegularExpression Id. */
-  int LANGMATCHES = 58;
+  int STR = 59;
   /** RegularExpression Id. */
-  int IS_URI = 59;
+  int DTYPE = 60;
   /** RegularExpression Id. */
-  int IS_IRI = 60;
+  int LANG = 61;
   /** RegularExpression Id. */
-  int IS_BLANK = 61;
+  int LANGMATCHES = 62;
   /** RegularExpression Id. */
-  int IS_LITERAL = 62;
+  int IS_URI = 63;
   /** RegularExpression Id. */
-  int REGEX = 63;
+  int IS_IRI = 64;
   /** RegularExpression Id. */
-  int SAME_TERM = 64;
+  int IS_BLANK = 65;
   /** RegularExpression Id. */
-  int TRUE = 65;
+  int IS_LITERAL = 66;
   /** RegularExpression Id. */
-  int FALSE = 66;
+  int REGEX = 67;
   /** RegularExpression Id. */
-  int MODIFY = 67;
+  int SAME_TERM = 68;
   /** RegularExpression Id. */
-  int INSERT = 68;
+  int TRUE = 69;
   /** RegularExpression Id. */
-  int DELETE = 69;
+  int FALSE = 70;
   /** RegularExpression Id. */
-  int DATA = 70;
+  int MODIFY = 71;
   /** RegularExpression Id. */
-  int ADD = 71;
+  int INSERT = 72;
   /** RegularExpression Id. */
-  int REMOVE = 72;
+  int DELETE = 73;
   /** RegularExpression Id. */
-  int LOAD = 73;
+  int DATA = 74;
   /** RegularExpression Id. */
-  int CLEAR = 74;
+  int ADD = 75;
   /** RegularExpression Id. */
-  int CREATE = 75;
+  int REMOVE = 76;
   /** RegularExpression Id. */
-  int SILENT = 76;
+  int LOAD = 77;
   /** RegularExpression Id. */
-  int DROP = 77;
+  int CLEAR = 78;
   /** RegularExpression Id. */
-  int INTO = 78;
+  int CREATE = 79;
   /** RegularExpression Id. */
-  int DIGITS = 79;
+  int SILENT = 80;
   /** RegularExpression Id. */
-  int INTEGER = 80;
+  int DROP = 81;
   /** RegularExpression Id. */
-  int DECIMAL = 81;
+  int INTO = 82;
   /** RegularExpression Id. */
-  int DOUBLE = 82;
+  int DIGITS = 83;
   /** RegularExpression Id. */
-  int INTEGER_POSITIVE = 83;
+  int INTEGER = 84;
   /** RegularExpression Id. */
-  int DECIMAL_POSITIVE = 84;
+  int DECIMAL = 85;
   /** RegularExpression Id. */
-  int DOUBLE_POSITIVE = 85;
+  int DOUBLE = 86;
   /** RegularExpression Id. */
-  int INTEGER_NEGATIVE = 86;
+  int INTEGER_POSITIVE = 87;
   /** RegularExpression Id. */
-  int DECIMAL_NEGATIVE = 87;
+  int DECIMAL_POSITIVE = 88;
   /** RegularExpression Id. */
-  int DOUBLE_NEGATIVE = 88;
+  int DOUBLE_POSITIVE = 89;
   /** RegularExpression Id. */
-  int EXPONENT = 89;
+  int INTEGER_NEGATIVE = 90;
   /** RegularExpression Id. */
-  int QUOTE_3D = 90;
+  int DECIMAL_NEGATIVE = 91;
   /** RegularExpression Id. */
-  int QUOTE_3S = 91;
+  int DOUBLE_NEGATIVE = 92;
   /** RegularExpression Id. */
-  int ECHAR = 92;
+  int EXPONENT = 93;
   /** RegularExpression Id. */
-  int STRING_LITERAL1 = 93;
+  int QUOTE_3D = 94;
   /** RegularExpression Id. */
-  int STRING_LITERAL2 = 94;
+  int QUOTE_3S = 95;
   /** RegularExpression Id. */
-  int STRING_LITERAL_LONG1 = 95;
+  int ECHAR = 96;
   /** RegularExpression Id. */
-  int STRING_LITERAL_LONG2 = 96;
+  int STRING_LITERAL1 = 97;
   /** RegularExpression Id. */
-  int LPAREN = 97;
+  int STRING_LITERAL2 = 98;
   /** RegularExpression Id. */
-  int RPAREN = 98;
+  int STRING_LITERAL_LONG1 = 99;
   /** RegularExpression Id. */
-  int NIL = 99;
+  int STRING_LITERAL_LONG2 = 100;
   /** RegularExpression Id. */
-  int LBRACE = 100;
+  int LPAREN = 101;
   /** RegularExpression Id. */
-  int RBRACE = 101;
+  int RPAREN = 102;
   /** RegularExpression Id. */
-  int LBRACKET = 102;
+  int NIL = 103;
   /** RegularExpression Id. */
-  int RBRACKET = 103;
+  int LBRACE = 104;
   /** RegularExpression Id. */
-  int ANON = 104;
+  int RBRACE = 105;
   /** RegularExpression Id. */
-  int SEMICOLON = 105;
+  int LBRACKET = 106;
   /** RegularExpression Id. */
-  int COMMA = 106;
+  int RBRACKET = 107;
   /** RegularExpression Id. */
-  int DOT = 107;
+  int ANON = 108;
   /** RegularExpression Id. */
-  int EQ = 108;
+  int SEMICOLON = 109;
   /** RegularExpression Id. */
-  int NE = 109;
+  int COMMA = 110;
   /** RegularExpression Id. */
-  int GT = 110;
+  int DOT = 111;
   /** RegularExpression Id. */
-  int LT = 111;
+  int EQ = 112;
   /** RegularExpression Id. */
-  int LE = 112;
+  int NE = 113;
   /** RegularExpression Id. */
-  int GE = 113;
+  int GT = 114;
   /** RegularExpression Id. */
-  int BANG = 114;
+  int LT = 115;
   /** RegularExpression Id. */
-  int TILDE = 115;
+  int LE = 116;
   /** RegularExpression Id. */
-  int COLON = 116;
+  int GE = 117;
   /** RegularExpression Id. */
-  int SC_OR = 117;
+  int BANG = 118;
   /** RegularExpression Id. */
-  int SC_AND = 118;
+  int TILDE = 119;
   /** RegularExpression Id. */
-  int PLUS = 119;
+  int COLON = 120;
   /** RegularExpression Id. */
-  int MINUS = 120;
+  int SC_OR = 121;
   /** RegularExpression Id. */
-  int STAR = 121;
+  int SC_AND = 122;
   /** RegularExpression Id. */
-  int SLASH = 122;
+  int PLUS = 123;
   /** RegularExpression Id. */
-  int DATATYPE = 123;
+  int MINUS = 124;
   /** RegularExpression Id. */
-  int AT = 124;
+  int STAR = 125;
   /** RegularExpression Id. */
-  int ASSIGN = 125;
+  int SLASH = 126;
   /** RegularExpression Id. */
-  int VBAR = 126;
+  int DATATYPE = 127;
   /** RegularExpression Id. */
-  int CARROT = 127;
+  int AT = 128;
   /** RegularExpression Id. */
-  int FPATH = 128;
+  int ASSIGN = 129;
   /** RegularExpression Id. */
-  int RPATH = 129;
+  int VBAR = 130;
   /** RegularExpression Id. */
-  int QMARK = 130;
+  int CARROT = 131;
   /** RegularExpression Id. */
-  int PN_CHARS_BASE = 131;
+  int FPATH = 132;
   /** RegularExpression Id. */
-  int PN_CHARS_U = 132;
+  int RPATH = 133;
   /** RegularExpression Id. */
-  int PN_CHARS = 133;
+  int QMARK = 134;
   /** RegularExpression Id. */
-  int PN_PREFIX = 134;
+  int NULL = 135;
   /** RegularExpression Id. */
-  int PN_LOCAL = 135;
+  int PN_CHARS_BASE = 136;
   /** RegularExpression Id. */
-  int VARNAME = 136;
+  int PN_CHARS_U = 137;
   /** RegularExpression Id. */
-  int UNKNOWN = 137;
+  int PN_CHARS = 138;
+  /** RegularExpression Id. */
+  int PN_PREFIX = 139;
+  /** RegularExpression Id. */
+  int PN_LOCAL = 140;
+  /** RegularExpression Id. */
+  int VARNAME = 141;
+  /** RegularExpression Id. */
+  int UNKNOWN = 142;
 
   /** Lexical state. */
   int DEFAULT = 0;
@@ -305,16 +315,20 @@
     "\"a\"",
     "\"base\"",
     "\"prefix\"",
+    "\"explain\"",
     "\"select\"",
     "\"distinct\"",
     "\"reduced\"",
     "\"describe\"",
     "\"construct\"",
     "\"ask\"",
+    "\"self\"",
+    "\"dataset\"",
     "\"limit\"",
     "\"offset\"",
     "\"order\"",
     "\"by\"",
+    "\"bindings\"",
     "\"asc\"",
     "\"desc\"",
     "\"named\"",
@@ -416,6 +430,7 @@
     "\"->\"",
     "\"<-\"",
     "\"?\"",
+    "\"null\"",
     "<PN_CHARS_BASE>",
     "<PN_CHARS_U>",
     "<PN_CHARS>",
Index: src/com/hp/hpl/jena/sparql/resultset/XMLOutputResultSet.java
===================================================================
--- src/com/hp/hpl/jena/sparql/resultset/XMLOutputResultSet.java	(revision 6629)
+++ src/com/hp/hpl/jena/sparql/resultset/XMLOutputResultSet.java	(working copy)
@@ -10,6 +10,7 @@
 import java.util.HashMap;
 import java.util.Map;
 
+import com.hp.hpl.jena.graph.TrackedNode;
 import com.hp.hpl.jena.query.ARQ;
 import com.hp.hpl.jena.query.QuerySolution;
 import com.hp.hpl.jena.query.ResultSet;
@@ -17,6 +18,7 @@
 import com.hp.hpl.jena.rdf.model.RDFNode;
 import com.hp.hpl.jena.rdf.model.Resource;
 import com.hp.hpl.jena.sparql.util.ALog;
+import com.hp.hpl.jena.sparql.util.FmtUtils;
 import com.hp.hpl.jena.sparql.util.IndentedWriter;
 
 /** XML Output (ResultSet format)
@@ -129,7 +131,10 @@
         
         out.print("<") ; 
         out.print(dfBinding) ;
-        out.println(" name=\""+varName+"\">") ;
+        out.print(" name=\""+varName+"\"");
+        if (node.asNode() instanceof TrackedNode)
+        	out.print(" source=\"" + TrackedNode.getProvenanceUri(node.asNode()).getURI() + "\"");
+        out.println(">") ;
         out.incIndent(INDENT) ;
         printBindingValue(node) ;
         out.decIndent(INDENT) ;
Index: src/com/hp/hpl/jena/sparql/algebra/opt/TransformJoinStrategy.java
===================================================================
--- src/com/hp/hpl/jena/sparql/algebra/opt/TransformJoinStrategy.java	(revision 6629)
+++ src/com/hp/hpl/jena/sparql/algebra/opt/TransformJoinStrategy.java	(working copy)
@@ -42,7 +42,7 @@
     //public Op transform(OpSequence opSequence, List<Op> elts)
     
     @Override
-    public Op transform(OpLeftJoin opLeftJoin, Op left, Op right)
+    public Op transform(OpLeftJoin opLeftJoin, Op opLeft, Op opRight)
     { 
       // Test whether we can do an indexed substitute into the right if possible.
       boolean canDoLinear = LeftJoinClassifier.isLinear(opLeftJoin) ;
@@ -54,8 +54,6 @@
           // RHS execution so the expression is evaluated by moving it to be 
           // a filter over the RHS pattern. 
           
-          Op opLeft = opLeftJoin.getLeft() ;
-          Op opRight = opLeftJoin.getRight() ;
           if (opLeftJoin.getExprs() != null )
               opRight = OpFilter.filter(opLeftJoin.getExprs(), opRight) ;
           return new OpConditional(opLeft, opRight) ;
Index: src/com/hp/hpl/jena/sparql/algebra/Op.java
===================================================================
--- src/com/hp/hpl/jena/sparql/algebra/Op.java	(revision 6629)
+++ src/com/hp/hpl/jena/sparql/algebra/Op.java	(working copy)
@@ -15,6 +15,8 @@
 {
     public void visit(OpVisitor opVisitor) ;
     public boolean equalTo(Op other, NodeIsomorphismMap labelMap) ;
+    public Object getAnnotation();
+    public void setAnnotation(Object obj);
 }
 
 /*
Index: Vocabularies/sparql-explain-notes.txt
===================================================================
--- Vocabularies/sparql-explain-notes.txt	(revision 0)
+++ Vocabularies/sparql-explain-notes.txt	(revision 0)
@@ -0,0 +1,39 @@
+[] a spx:SelectQuery ;
+  spx:query "SELECT DISTINCT ?type WHERE { [] a ?type } ORDER BY ?type" ;
+  spx:expectedSolutions "23"^^xsd:int ;   # REQUIRED by implementations
+  spx:minSolutions "10"^^xsd:int ;        # optional guaranteed lower bound
+                                          # if absent, assume 0 (possibly no results at all)
+  spx:maxSolutions "100"^^xsd:int ;       # optional guaranteed upper bound
+                                          # if absent, assume positive infinity
+  spx:timeTotal    "160"^^xsd:int ;       # [ms] = timeToFirst + (expectedSolutions-1)*timeToNext
+  optionally more accurate by sub properties:
+    spx:timeToFirst  "50"^^xsd:int ;        # optional [ms] for the first result
+    spx:timeToNext   "5"^^xsd:int ;         # optional [ms] for the following results
+  spx:plan "implementation-specific details on the query plan" ;
+.
+
+[] a spx:AskQuery ;
+  spx:query ...
+  spx:time ...
+  spx:plan ...
+.
+
+[] a spx:DescribeQuery ;
+  spx:query ...
+  spx:expectedTriples "210"^^xsd:int ;     # REQUIRED by implementations
+  spx:minTriples      "0"^^xsd:int ;       # optional, if absent assume 0
+  spx:maxTriples      "1000"^^xsd:int ;    # optional, if absent assume positive infinity
+  spx:time            "230"^^xsd:int ;     # total time in [ms]
+  spx:plan ...
+.
+
+[] a spx:ConstructQuery ;
+  spx:query ...
+  spx:expectedTriples "210"^^xsd:int ;     # REQUIRED by implementations
+  spx:minTriples      "0"^^xsd:int ;       # optional, if absent assume 0
+  spx:maxTriples      "1000"^^xsd:int ;    # optional, if absent assume positive infinity
+  spx:time            "230"^^xsd:int ;     # total time in [ms]
+  spx:plan ...
+.
+
+times exclude retrieval times - up to the clients (can be calculated based on network connection + estimates)
